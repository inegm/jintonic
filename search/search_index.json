{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jintonic","text":"<p>A package of tools for composition in just intonation with Python.</p> <p>David B. Doty's technical definition of just intonation :</p> <p>Just Intonation is any system of tuning in which all of the intervals can be represented by whole-number frequency ratios, with a strongly implied preference for the simplest ratios compatible with a given musical purpose.</p> <p>You can find a more lyrical definition in the first chapter of his primer, which is available online.</p> <p>I strongly recommend his book : Just Intonation Primer.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install jintonic\n</code></pre>"},{"location":"api/chords/","title":"chords","text":""},{"location":"api/chords/#justlatticechord","title":"JustLatticeChord","text":"<p>This class implements chords based on lattice coordinates.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/chords.py</code> <pre><code>class JustLatticeChord:\n\"\"\"This class implements chords based on lattice coordinates.\"\"\"\n\n    def __init__(\n        self,\n        fundamental: float,\n        root: List[int],\n        nodes: List[List[int]],\n    ):\n\"\"\"Initializes a JustLatticeChord.\n\n        Parameters:\n            fundamental: Fundamental pitch in Hertz.\n            root: Root lattice node (the chord's root tone)\n            nodes: Lattice nodes of each constituent chord tone.\n\n        Examples:\n            &gt;&gt;&gt; nodes = [[-1, 0, 1], [1, 0, 0], [0, 0, 1]]\n            &gt;&gt;&gt; JustLatticeChord(fundamental=100.0, root=[1, 0, 0], nodes=nodes)\n            JustLatticeChord(100.0 Hz, [3/2, 7/4, 9/8, 21/16], [3-7-9-21])\n        \"\"\"\n        self._fundamental: float = float(fundamental)\n        self._nodes = nodes\n        self._root = root\n        self.lattice = JustLattice(fundamental=self._fundamental)\n\n    @classmethod\n    def from_name(\n        cls,\n        fundamental: float,\n        root: List[int],\n        name: str,\n    ) -&gt; JustLatticeChord:\n\"\"\"Initializes a JustLatticeChord from a conventional chord name.\n\n        Parameters:\n            fundamental: The fundamental frequency in Hertz\n            root: The root node lattice coordinates\n            name: The chord name\n\n        Returns:\n            A JustLatticeChord\n\n        The list of valid names is:\n            - \"sub-minor triad\"\n            - \"minor triad\"\n            - \"diminished triad\"\n            - \"major triad\"\n            - \"sub-minor seventh\"\n            - \"minor seventh\"\n            - \"half-diminished seventh\"\n            - \"major seventh\"\n            - \"super-major seventh\"\n            - \"dominant seventh\"\n            - \"added second\"\n            - \"minor ninth\"\n            - \"major ninth\"\n            - \"dominant ninth\"\n            - \"4-6-7\"\n            - \"5-7-9\"\n\n        Examples:\n\n            &gt;&gt;&gt; JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n            JustLatticeChord(60.0 Hz, [1/1, 6/5, 3/2], [5-3-15])\n\n            &gt;&gt;&gt; JustLatticeChord.from_name(60, [-1, 0, 0], 'major triad')\n            JustLatticeChord(60.0 Hz, [4/3, 5/3, 1/1], [1-5-3])\n        \"\"\"\n        nodes = {\n            \"sub-minor triad\": [[1, 0, 0], [-1, 0, 1]],\n            \"minor triad\": [[1, -1, 0], [1, 0, 0]],\n            \"diminished triad\": [[1, -1, 0], [0, -1, 1]],\n            \"major triad\": [[0, 1, 0], [1, 0, 0]],\n            \"sub-minor seventh\": [[-1, 0, 1], [1, 0, 0], [0, 0, 1]],\n            \"minor seventh\": [[1, -1, 0], [1, 0, 0], [2, -1, 0]],\n            \"half-diminished seventh\": [[1, -1, 0], [0, -1, 1], [2, -1, 0]],\n            \"major seventh\": [[0, 1, 0], [1, 0, 0], [1, 1, 0]],\n            \"super-major seventh\": [[2, 0, -1], [1, 0, 0], [3, 0, -1]],\n            \"dominant seventh\": [[0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 0, 1]],\n            \"added second\": [[0, 1, 0], [1, 0, 0], [2, -1, 0]],\n            \"minor ninth\": [[1, -1, 0], [1, 0, 0], [2, -1, 0], [2, 0, 0]],\n            \"major ninth\": [[0, 1, 0], [1, 0, 0], [1, 1, 0], [2, 0, 0]],\n            \"dominant ninth\": [[0, 1, 0], [1, 0, 0], [0, 0, 1], [2, 0, 0]],\n            \"4-6-7\": [[1, 0, 0], [0, 0, 1]],\n            \"5-7-9\": [[0, -1, 1], [2, -1, 0]],\n        }\n        try:\n            return cls(fundamental, root, nodes[name.lower()])\n        except KeyError:\n            return NotImplemented\n\n    def transpose(self, node: List[int]) -&gt; JustLatticeChord:\n\"\"\"JustLatticeChord transposition.\n\n        Parameters:\n            node: The target root node of the transposed chord.\n\n        Returns:\n            A transposed JustLatticeChord\n\n        Note:\n            Returns a copy\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n            &gt;&gt;&gt; node = [1, 0, 0]\n            &gt;&gt;&gt; chord.transpose(node)\n            JustLatticeChord(60.0 Hz, [3/2, 9/5, 9/8], [5-3-15])\n        \"\"\"\n        chord = deepcopy(self)\n        chord.root = node\n        chord.lattice.to_node((node))\n\n        return chord\n\n    def pivot(self, axis: int = 3) -&gt; JustLatticeChord:\n\"\"\"Pivots the JustLatticeChord along the given axis.\n\n        Parameters:\n            axis: Prime limit axis (a prime number)\n\n        Returns:\n            A pivoted JustLatticeChord\n\n        Note:\n            Returns a copy\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'major triad')\n            &gt;&gt;&gt; chord.pivot(3)\n            JustLatticeChord(60.0 Hz, [1/1, 5/4, 4/3], [3-15-1])\n        \"\"\"\n        if axis &gt; self.prime_limit:\n            raise ValueError(\n                \"Cannot pivot on an axis greater than the chord's prime limit.\"\n            )\n        chord = deepcopy(self)\n        axis_ix = generate_primes(chord.prime_limit)[1:].index(axis)\n        base = min(node[axis_ix] for node in chord._nodes)\n        base = 0\n        for i, node in enumerate(chord._nodes):\n            node[axis_ix] = base - node[axis_ix]\n            chord._nodes[i] = node\n        return chord\n\n    @property\n    def fundamental(self):\n        return self._fundamental\n\n    @property\n    def nodes(self):\n\"\"\"JustLatticeChord nodes.\"\"\"\n        return self._nodes\n\n    @nodes.setter\n    def nodes(self, values: List[List[int]]):\n\"\"\"JustLatticeChord nodes.\n\n        Parameters:\n            values: Constituent lattice nodes.\n        \"\"\"\n\"\"\"Sets (and expands) JustLatticeChord nodes.\"\"\"\n        max_len = max((len(node) for node in values))\n        self._nodes = []\n        for node in values:\n            self._nodes.append(node + (max_len - len(node)) * [0])\n\n    @property\n    def root(self):\n\"\"\"JustLatticeChord root node.\"\"\"\n        return self._root\n\n    @root.setter\n    def root(self, value: List[int]):\n\"\"\"Sets (and expands) JustLatticeChord root node.\n\n        Parameters:\n            value: Root lattice node\n        \"\"\"\n        max_len = max((len(node) for node in self._nodes))\n        self._root = value + (max_len - len(value)) * [0]\n\n    @property\n    def tones(self) -&gt; List[JustInterval]:\n\"\"\"JustLatticeChord constituent intervals from root (tones).\n\n        Returns:\n            The tones of the chord as JustIntervals from the fundamental.\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'major triad')\n            &gt;&gt;&gt; chord.tones\n            [JustInterval(1, 1), JustInterval(5, 4), JustInterval(3, 2)]\n        \"\"\"\n        tones = []\n        self.lattice.to_node(self._root)\n        root_tone = self.lattice.tone\n        tones.append(root_tone)\n        for node in self._nodes:\n            self.lattice.to_node(self._root)\n            constituent = self.lattice.traverse(node)\n            constituent_tone = constituent.tone\n            tones.append(constituent_tone)\n        self.lattice.to_node(self._root)\n\n        return tones\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"JustLatticeChord prime limit.\"\"\"\n        return max([tone.prime_limit for tone in self.tones])\n\n    @property\n    def harmonics(self) -&gt; List[int]:\n\"\"\"JustLatticeChord harmonics (relative frequencies).\n\n        Returns:\n            The lattice's prime limit\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n            &gt;&gt;&gt; chord.harmonics\n            [10, 12, 15]\n        \"\"\"\n        return tones_to_harmonic_segment(self.tones)\n\n    @property\n    def identities(self) -&gt; List[int]:\n\"\"\"JustLatticeChord constituent identities.\n\n        Returns:\n            The constituent identities\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n            &gt;&gt;&gt; chord.identities\n            [5, 3, 15]\n        \"\"\"\n        return harmonic_segment_to_identities(self.harmonics)\n\n    @property\n    def hertz(self) -&gt; List[float]:\n\"\"\"JustLatticeChord constituent Hertz values.\n\n        Returns:\n            The frequencies in Hertz of the constituent pitches\n\n        Examples:\n            &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n            &gt;&gt;&gt; chord.hertz\n            [60.0, 72.0, 90.0]\n        \"\"\"\n        tones = [self.tones[0]]\n        for tone in self.tones[1:]:\n            while tone &lt; tones[-1]:\n                tone += JustInterval(2, 1)\n            tones.append(tone)\n        return [self._fundamental * tone for tone in tones]\n\n    @property\n    def complement(self) -&gt; JustLatticeChord:\n\"\"\"JustLatticeChord complement.\n\n        Every node's relationship to the root node is inverted.\n\n        Returns:\n            A JustLatticeChord that is the complement of this one\n\n        Note:\n            Returns a copy.\n\n        Examples:\n            &gt;&gt;&gt; nodes = [[2, 0], [0, 1], [-1, 0], [1, 0]]\n            &gt;&gt;&gt; chord = JustLatticeChord(60, [0, 0, 0], nodes)\n            &gt;&gt;&gt; chord.complement\n            JustLatticeChord(60.0 Hz, [1/1, 16/9, 8/5, 3/2, 4/3], [45-5-9-135-15])\n        \"\"\"\n        nodes = []\n        for node in self._nodes:\n            nodes.append(list(map(lambda x, y: y - x, node, self._root)))\n        return JustLatticeChord(self._fundamental, self._root, nodes)\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        tones = \", \".join(\n            [\n                \"/\".join([str(tone.numerator), str(tone.denominator)])\n                for tone in self.tones\n            ]\n        )\n        identities = \", \".join(\n            [\"-\".join([str(identity) for identity in self.identities])]\n        )\n        return \"{}({} Hz, [{}], [{}])\".format(\n            self.__class__.__name__, self._fundamental, tones, identities\n        )\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.prime_limit","title":"<code>prime_limit: int</code>  <code>property</code>","text":"<p>JustLatticeChord prime limit.</p>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.tones","title":"<code>tones: List[JustInterval]</code>  <code>property</code>","text":"<p>JustLatticeChord constituent intervals from root (tones).</p> <p>Returns:</p> Type Description <code>List[JustInterval]</code> <p>The tones of the chord as JustIntervals from the fundamental.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'major triad')\n&gt;&gt;&gt; chord.tones\n[JustInterval(1, 1), JustInterval(5, 4), JustInterval(3, 2)]\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.hertz","title":"<code>hertz: List[float]</code>  <code>property</code>","text":"<p>JustLatticeChord constituent Hertz values.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>The frequencies in Hertz of the constituent pitches</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n&gt;&gt;&gt; chord.hertz\n[60.0, 72.0, 90.0]\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.harmonics","title":"<code>harmonics: List[int]</code>  <code>property</code>","text":"<p>JustLatticeChord harmonics (relative frequencies).</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The lattice's prime limit</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n&gt;&gt;&gt; chord.harmonics\n[10, 12, 15]\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.identities","title":"<code>identities: List[int]</code>  <code>property</code>","text":"<p>JustLatticeChord constituent identities.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The constituent identities</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n&gt;&gt;&gt; chord.identities\n[5, 3, 15]\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.__init__","title":"<code>__init__(fundamental, root, nodes)</code>","text":"<p>Initializes a JustLatticeChord.</p> <p>Parameters:</p> Name Type Description Default <code>fundamental</code> <code>float</code> <p>Fundamental pitch in Hertz.</p> required <code>root</code> <code>List[int]</code> <p>Root lattice node (the chord's root tone)</p> required <code>nodes</code> <code>List[List[int]]</code> <p>Lattice nodes of each constituent chord tone.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; nodes = [[-1, 0, 1], [1, 0, 0], [0, 0, 1]]\n&gt;&gt;&gt; JustLatticeChord(fundamental=100.0, root=[1, 0, 0], nodes=nodes)\nJustLatticeChord(100.0 Hz, [3/2, 7/4, 9/8, 21/16], [3-7-9-21])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/chords.py</code> <pre><code>def __init__(\n    self,\n    fundamental: float,\n    root: List[int],\n    nodes: List[List[int]],\n):\n\"\"\"Initializes a JustLatticeChord.\n\n    Parameters:\n        fundamental: Fundamental pitch in Hertz.\n        root: Root lattice node (the chord's root tone)\n        nodes: Lattice nodes of each constituent chord tone.\n\n    Examples:\n        &gt;&gt;&gt; nodes = [[-1, 0, 1], [1, 0, 0], [0, 0, 1]]\n        &gt;&gt;&gt; JustLatticeChord(fundamental=100.0, root=[1, 0, 0], nodes=nodes)\n        JustLatticeChord(100.0 Hz, [3/2, 7/4, 9/8, 21/16], [3-7-9-21])\n    \"\"\"\n    self._fundamental: float = float(fundamental)\n    self._nodes = nodes\n    self._root = root\n    self.lattice = JustLattice(fundamental=self._fundamental)\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.from_name","title":"<code>from_name(fundamental, root, name)</code>  <code>classmethod</code>","text":"<p>Initializes a JustLatticeChord from a conventional chord name.</p> <p>Parameters:</p> Name Type Description Default <code>fundamental</code> <code>float</code> <p>The fundamental frequency in Hertz</p> required <code>root</code> <code>List[int]</code> <p>The root node lattice coordinates</p> required <code>name</code> <code>str</code> <p>The chord name</p> required <p>Returns:</p> Type Description <code>JustLatticeChord</code> <p>A JustLatticeChord</p> The list of valid names is <ul> <li>\"sub-minor triad\"</li> <li>\"minor triad\"</li> <li>\"diminished triad\"</li> <li>\"major triad\"</li> <li>\"sub-minor seventh\"</li> <li>\"minor seventh\"</li> <li>\"half-diminished seventh\"</li> <li>\"major seventh\"</li> <li>\"super-major seventh\"</li> <li>\"dominant seventh\"</li> <li>\"added second\"</li> <li>\"minor ninth\"</li> <li>\"major ninth\"</li> <li>\"dominant ninth\"</li> <li>\"4-6-7\"</li> <li>\"5-7-9\"</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\nJustLatticeChord(60.0 Hz, [1/1, 6/5, 3/2], [5-3-15])\n</code></pre> <pre><code>&gt;&gt;&gt; JustLatticeChord.from_name(60, [-1, 0, 0], 'major triad')\nJustLatticeChord(60.0 Hz, [4/3, 5/3, 1/1], [1-5-3])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/chords.py</code> <pre><code>@classmethod\ndef from_name(\n    cls,\n    fundamental: float,\n    root: List[int],\n    name: str,\n) -&gt; JustLatticeChord:\n\"\"\"Initializes a JustLatticeChord from a conventional chord name.\n\n    Parameters:\n        fundamental: The fundamental frequency in Hertz\n        root: The root node lattice coordinates\n        name: The chord name\n\n    Returns:\n        A JustLatticeChord\n\n    The list of valid names is:\n        - \"sub-minor triad\"\n        - \"minor triad\"\n        - \"diminished triad\"\n        - \"major triad\"\n        - \"sub-minor seventh\"\n        - \"minor seventh\"\n        - \"half-diminished seventh\"\n        - \"major seventh\"\n        - \"super-major seventh\"\n        - \"dominant seventh\"\n        - \"added second\"\n        - \"minor ninth\"\n        - \"major ninth\"\n        - \"dominant ninth\"\n        - \"4-6-7\"\n        - \"5-7-9\"\n\n    Examples:\n\n        &gt;&gt;&gt; JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n        JustLatticeChord(60.0 Hz, [1/1, 6/5, 3/2], [5-3-15])\n\n        &gt;&gt;&gt; JustLatticeChord.from_name(60, [-1, 0, 0], 'major triad')\n        JustLatticeChord(60.0 Hz, [4/3, 5/3, 1/1], [1-5-3])\n    \"\"\"\n    nodes = {\n        \"sub-minor triad\": [[1, 0, 0], [-1, 0, 1]],\n        \"minor triad\": [[1, -1, 0], [1, 0, 0]],\n        \"diminished triad\": [[1, -1, 0], [0, -1, 1]],\n        \"major triad\": [[0, 1, 0], [1, 0, 0]],\n        \"sub-minor seventh\": [[-1, 0, 1], [1, 0, 0], [0, 0, 1]],\n        \"minor seventh\": [[1, -1, 0], [1, 0, 0], [2, -1, 0]],\n        \"half-diminished seventh\": [[1, -1, 0], [0, -1, 1], [2, -1, 0]],\n        \"major seventh\": [[0, 1, 0], [1, 0, 0], [1, 1, 0]],\n        \"super-major seventh\": [[2, 0, -1], [1, 0, 0], [3, 0, -1]],\n        \"dominant seventh\": [[0, 1, 0], [1, 0, 0], [1, 1, 0], [0, 0, 1]],\n        \"added second\": [[0, 1, 0], [1, 0, 0], [2, -1, 0]],\n        \"minor ninth\": [[1, -1, 0], [1, 0, 0], [2, -1, 0], [2, 0, 0]],\n        \"major ninth\": [[0, 1, 0], [1, 0, 0], [1, 1, 0], [2, 0, 0]],\n        \"dominant ninth\": [[0, 1, 0], [1, 0, 0], [0, 0, 1], [2, 0, 0]],\n        \"4-6-7\": [[1, 0, 0], [0, 0, 1]],\n        \"5-7-9\": [[0, -1, 1], [2, -1, 0]],\n    }\n    try:\n        return cls(fundamental, root, nodes[name.lower()])\n    except KeyError:\n        return NotImplemented\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.pivot","title":"<code>pivot(axis=3)</code>","text":"<p>Pivots the JustLatticeChord along the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>Prime limit axis (a prime number)</p> <code>3</code> <p>Returns:</p> Type Description <code>JustLatticeChord</code> <p>A pivoted JustLatticeChord</p> Note <p>Returns a copy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'major triad')\n&gt;&gt;&gt; chord.pivot(3)\nJustLatticeChord(60.0 Hz, [1/1, 5/4, 4/3], [3-15-1])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/chords.py</code> <pre><code>def pivot(self, axis: int = 3) -&gt; JustLatticeChord:\n\"\"\"Pivots the JustLatticeChord along the given axis.\n\n    Parameters:\n        axis: Prime limit axis (a prime number)\n\n    Returns:\n        A pivoted JustLatticeChord\n\n    Note:\n        Returns a copy\n\n    Examples:\n        &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'major triad')\n        &gt;&gt;&gt; chord.pivot(3)\n        JustLatticeChord(60.0 Hz, [1/1, 5/4, 4/3], [3-15-1])\n    \"\"\"\n    if axis &gt; self.prime_limit:\n        raise ValueError(\n            \"Cannot pivot on an axis greater than the chord's prime limit.\"\n        )\n    chord = deepcopy(self)\n    axis_ix = generate_primes(chord.prime_limit)[1:].index(axis)\n    base = min(node[axis_ix] for node in chord._nodes)\n    base = 0\n    for i, node in enumerate(chord._nodes):\n        node[axis_ix] = base - node[axis_ix]\n        chord._nodes[i] = node\n    return chord\n</code></pre>"},{"location":"api/chords/#jintonic.chords.JustLatticeChord.transpose","title":"<code>transpose(node)</code>","text":"<p>JustLatticeChord transposition.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>List[int]</code> <p>The target root node of the transposed chord.</p> required <p>Returns:</p> Type Description <code>JustLatticeChord</code> <p>A transposed JustLatticeChord</p> Note <p>Returns a copy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n&gt;&gt;&gt; node = [1, 0, 0]\n&gt;&gt;&gt; chord.transpose(node)\nJustLatticeChord(60.0 Hz, [3/2, 9/5, 9/8], [5-3-15])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/chords.py</code> <pre><code>def transpose(self, node: List[int]) -&gt; JustLatticeChord:\n\"\"\"JustLatticeChord transposition.\n\n    Parameters:\n        node: The target root node of the transposed chord.\n\n    Returns:\n        A transposed JustLatticeChord\n\n    Note:\n        Returns a copy\n\n    Examples:\n        &gt;&gt;&gt; chord = JustLatticeChord.from_name(60, [0, 0, 0], 'minor triad')\n        &gt;&gt;&gt; node = [1, 0, 0]\n        &gt;&gt;&gt; chord.transpose(node)\n        JustLatticeChord(60.0 Hz, [3/2, 9/5, 9/8], [5-3-15])\n    \"\"\"\n    chord = deepcopy(self)\n    chord.root = node\n    chord.lattice.to_node((node))\n\n    return chord\n</code></pre>"},{"location":"api/harmonics/","title":"harmonics","text":""},{"location":"api/harmonics/#jintonic.harmonics.tones_to_harmonic_segment","title":"<code>tones_to_harmonic_segment(tones, sub=False)</code>","text":"<p>Converts a series of tones to a harmonic or sub-harmonic segment.</p> <p>Parameters:</p> Name Type Description Default <code>tones</code> <code>List[JustInterval]</code> <p>A series of tones.</p> required <code>sub</code> <code>bool</code> <p>When True, returns a sub-harmonic segment. Else, a harmonic  (overtone) segment.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>The harmonic, or sub-harmonic, segment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from .intervals import JustInterval\n&gt;&gt;&gt; tones = []\n&gt;&gt;&gt; tones.append(JustInterval(16, 15))\n&gt;&gt;&gt; tones.append(JustInterval(4, 3))\n&gt;&gt;&gt; tones.append(JustInterval(8, 5))\n&gt;&gt;&gt; tones_to_harmonic_segment(tones)\n[4, 5, 6]\n</code></pre> <pre><code>&gt;&gt;&gt; tones = []\n&gt;&gt;&gt; tones.append(JustInterval(9, 5))\n&gt;&gt;&gt; tones.append(JustInterval(9, 8))\n&gt;&gt;&gt; tones.append(JustInterval(27, 20))\n&gt;&gt;&gt; tones.append(JustInterval(63, 40))\n&gt;&gt;&gt; tones_to_harmonic_segment(tones)\n[4, 5, 6, 7]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/harmonics.py</code> <pre><code>def tones_to_harmonic_segment(\n    tones: List[JustInterval],\n    sub: bool = False,\n) -&gt; List[int]:\n\"\"\"Converts a series of tones to a harmonic or sub-harmonic segment.\n\n    Parameters:\n        tones: A series of tones.\n        sub: When True, returns a sub-harmonic segment. Else, a harmonic\n             (overtone) segment.\n\n    Returns:\n        The harmonic, or sub-harmonic, segment\n\n    Examples:\n        &gt;&gt;&gt; from .intervals import JustInterval\n        &gt;&gt;&gt; tones = []\n        &gt;&gt;&gt; tones.append(JustInterval(16, 15))\n        &gt;&gt;&gt; tones.append(JustInterval(4, 3))\n        &gt;&gt;&gt; tones.append(JustInterval(8, 5))\n        &gt;&gt;&gt; tones_to_harmonic_segment(tones)\n        [4, 5, 6]\n\n        &gt;&gt;&gt; tones = []\n        &gt;&gt;&gt; tones.append(JustInterval(9, 5))\n        &gt;&gt;&gt; tones.append(JustInterval(9, 8))\n        &gt;&gt;&gt; tones.append(JustInterval(27, 20))\n        &gt;&gt;&gt; tones.append(JustInterval(63, 40))\n        &gt;&gt;&gt; tones_to_harmonic_segment(tones)\n        [4, 5, 6, 7]\n    \"\"\"\n    if sub:\n        _tones = [(tone.denominator, tone.numerator) for tone in tones]\n    else:\n        _tones = [(tone.numerator, tone.denominator) for tone in tones]\n\n    lcm_tones = lcm([tone[1] for tone in _tones])\n    # print(lcm_tones)\n    segment = [tone[0] * (lcm_tones // tone[1]) for tone in _tones]\n    # print(segment)\n    gcd_segment = reduce(gcd, segment)\n    segment = [harmonic // gcd_segment for harmonic in segment]\n    if sub:\n        segment.reverse()\n    for i, harmonic in enumerate(segment):\n        try:\n            if harmonic / 2 == segment[i + 1] - 1:\n                segment[i] = harmonic // 2\n        except IndexError:\n            continue\n    if sub:\n        segment.reverse()\n    return segment\n</code></pre>"},{"location":"api/harmonics/#jintonic.harmonics.harmonic_to_identity","title":"<code>harmonic_to_identity(harmonic)</code>","text":"<p>Converts a harmonic number to its tone identity.</p> Paramters <p>harmonic: A harmonic number</p> <p>Returns:</p> Type Description <code>int</code> <p>The harmonic's tone identity</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; harmonic_to_identity(6)\n3\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/harmonics.py</code> <pre><code>def harmonic_to_identity(harmonic: int) -&gt; int:\n\"\"\"Converts a harmonic number to its tone identity.\n\n    Paramters:\n        harmonic: A harmonic number\n\n    Returns:\n        The harmonic's tone identity\n\n    Examples:\n        &gt;&gt;&gt; harmonic_to_identity(6)\n        3\n    \"\"\"\n    return harmonic // (2 ** (prime_factors(harmonic).count(2)))\n</code></pre>"},{"location":"api/harmonics/#jintonic.harmonics.harmonic_segment_to_identities","title":"<code>harmonic_segment_to_identities(segment)</code>","text":"<p>Converts a harmonic or sub-harmonic segment to its tone identities.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>List[int]</code> <p>A harmonic, or sub-harmonic, segment</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>The tone identities of each harmonic in a segment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; harmonic_segment_to_identities([4, 5, 6])\n[1, 5, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; harmonic_segment_to_identities([10, 12, 15])\n[5, 3, 15]\n</code></pre> <pre><code>&gt;&gt;&gt; harmonic_segment_to_identities([4, 5, 6, 7, 9])\n[1, 5, 3, 7, 9]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/harmonics.py</code> <pre><code>def harmonic_segment_to_identities(segment: List[int]) -&gt; List[int]:\n\"\"\"Converts a harmonic or sub-harmonic segment to its tone identities.\n\n    Parameters:\n        segment: A harmonic, or sub-harmonic, segment\n\n    Returns:\n        The tone identities of each harmonic in a segment\n\n    Examples:\n        &gt;&gt;&gt; harmonic_segment_to_identities([4, 5, 6])\n        [1, 5, 3]\n\n        &gt;&gt;&gt; harmonic_segment_to_identities([10, 12, 15])\n        [5, 3, 15]\n\n        &gt;&gt;&gt; harmonic_segment_to_identities([4, 5, 6, 7, 9])\n        [1, 5, 3, 7, 9]\n    \"\"\"\n    return [harmonic_to_identity(harmonic) for harmonic in segment]\n</code></pre>"},{"location":"api/intervals/","title":"intervals","text":""},{"location":"api/intervals/#jintonic.intervals.primary_interval","title":"<code>primary_interval(prime_limit, sub_harmonic=False, max_pot_exp=500)</code>","text":"<p>Returns the primary interval for a given prime limit.</p> <p>Parameters:</p> Name Type Description Default <code>prime_limit</code> <code>int</code> <p>A prime number</p> required <code>sub_harmonic</code> <code>bool</code> <p>Whether the primary interval is a harmonic primary (the default) or a sub-harmonic primary.</p> <code>False</code> <code>max_pot_exp</code> <code>int</code> <p>Maximum power of two exponent to limit iterations</p> <code>500</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; primary_interval(7)\nJustInterval(7, 4)\n</code></pre> <pre><code>&gt;&gt;&gt; primary_interval(19)\nJustInterval(19, 16)\n</code></pre> <pre><code>&gt;&gt;&gt; primary_interval(3, sub_harmonic=True)\nJustInterval(4, 3)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>def primary_interval(\n    prime_limit: int,\n    sub_harmonic: bool = False,\n    max_pot_exp: int = 500,\n) -&gt; JustInterval:\n\"\"\"Returns the primary interval for a given prime limit.\n\n    Parameters:\n        prime_limit: A prime number\n        sub_harmonic: Whether the primary interval is a harmonic primary\n            (the default) or a sub-harmonic primary.\n        max_pot_exp: Maximum power of two exponent to limit iterations\n\n    Examples:\n        &gt;&gt;&gt; primary_interval(7)\n        JustInterval(7, 4)\n\n        &gt;&gt;&gt; primary_interval(19)\n        JustInterval(19, 16)\n\n        &gt;&gt;&gt; primary_interval(3, sub_harmonic=True)\n        JustInterval(4, 3)\n    \"\"\"\n    pot = 2\n    exp = 2\n    max_pot = 2**max_pot_exp\n    while (pot**exp &lt; prime_limit) and (pot &lt; max_pot):\n        exp += 1\n    pot = pot ** (exp - 1)\n    if sub_harmonic:\n        return JustInterval(prime_limit, pot).complement\n    return JustInterval(prime_limit, pot)\n</code></pre>"},{"location":"api/intervals/#justinterval","title":"JustInterval","text":"<p>This class implements just intonation intervals.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>class JustInterval:\n\"\"\"This class implements just intonation intervals.\"\"\"\n\n    def __init__(self, numerator: int, denominator: int):\n\"\"\"Initializes a JustInterval.\n\n        Parameters:\n            numerator: Numerator\n            denominator: Denominator\n\n        Examples:\n            &gt;&gt;&gt; JustInterval(4, 3)\n            JustInterval(4, 3)\n        \"\"\"\n        if not (isinstance(numerator, int) and isinstance(denominator, int)):\n            msg = \"Both components must be integers. \"\n            msg += \"Got numerator: {}, denominator: {}\".format(\n                type(numerator), type(denominator)\n            )\n            raise TypeError(msg)\n\n        if denominator &gt; numerator:\n            msg = \"Numerator must be greater than or equal to denominator. \"\n            msg += \"Got numerator: {}, denominator: {}\".format(numerator, denominator)\n            raise ValueError(msg)\n\n        if denominator == 0:\n            raise ZeroDivisionError(\"JustRatio({}, 0)\".format(numerator))\n\n        if denominator &lt; 1:\n            msg = \"Denominator must be greater than 0. \"\n            msg += \"Got: {}\".format(numerator)\n            raise ValueError(msg)\n\n        common = gcd(numerator, denominator)\n        numerator //= common\n        denominator //= common\n\n        self._numerator = numerator\n        self._denominator = denominator\n\n    @classmethod\n    def from_string(cls, interval: str) -&gt; JustInterval:\n\"\"\"Creates a JustInterval from a string representation.\n\n        Parameters:\n            interval: A string representation of an interval in the\n                `numerator:denominator` format.\n\n        Returns:\n            A JustInterval\n\n        Examples:\n            &gt;&gt;&gt; JustInterval.from_string('3:2')\n            JustInterval(3, 2)\n\n            &gt;&gt;&gt; JustInterval.from_string('3:3')\n            JustInterval(1, 1)\n\n            &gt;&gt;&gt; JustInterval.from_string('6:3')\n            JustInterval(2, 1)\n        \"\"\"\n        re_match = _RATIO_FORMAT.match(interval)\n        if re_match is None:\n            msg = \"Invalid literal for JustRatio: {}\".format(interval)\n            raise ValueError(msg)\n        try:\n            numerator = int(re_match.group(\"num\"))\n            denominator = int(re_match.group(\"denom\"))\n            return JustInterval(numerator=numerator, denominator=denominator)\n        except ValueError:\n            msg = \"Invalid literal for JustRatio: {}\".format(interval)\n            raise ValueError(msg)\n\n    @classmethod\n    def from_two_hertz(cls, apitch: float, bpitch: float) -&gt; JustInterval:\n\"\"\"Creates a JustInterval from two Hertz values.\n\n        Parameters:\n            apitch: A value in Hertz (which will be truncated to an int)\n            bpitch: A value in Hertz (which will be truncated to an int)\n\n        Returns:\n            A JustInterval\n\n        Examples:\n            &gt;&gt;&gt; JustInterval.from_two_hertz(220, 440)\n            JustInterval(2, 1)\n        \"\"\"\n        smaller = apitch if apitch &lt;= bpitch else bpitch\n        greater = apitch if apitch &gt; bpitch else bpitch\n\n        return cls(int(greater), int(smaller))\n\n    def divisions(\n        self,\n        divisor: int,\n        prime_limit: int = 7,\n        max_iterations: int = 30,\n    ) -&gt; List[JustInterval]:\n\"\"\"Divides a just interval into intervals that respect a prime limit.\n\n        Parameters:\n            divisor: Number of divisions.\n            prime_limit: The prime limit, a prime number.\n            max_iterations: A limit to how many divisions this method will\n                try before giving up on dividing within the prime limit.\n\n        Returns:\n            The resulting JustIntervals\n\n        Examples:\n            &gt;&gt;&gt; JustInterval(2, 1).divisions(4, 5)\n            [JustInterval(10, 9), JustInterval(9, 8), JustInterval(6, 5),\n            JustInterval(4, 3)]\n\n            &gt;&gt;&gt; JustInterval(16, 15).divisions(2, 31)\n            [JustInterval(32, 31), JustInterval(31, 30)]\n        \"\"\"\n        if not is_prime(prime_limit):\n            msg = \"The prime limit must be a prime number. \"\n            msg += \"Got: '{}'\".format(prime_limit)\n            raise ValueError(msg)\n\n        factor = divisor\n        divisions: List[JustInterval] = []\n        divrange: List[int] = []\n        i = 0\n        while i &lt;= max_iterations:\n            num = self.numerator * factor\n            denom = self.denominator * factor\n\n            divrange = list(range(denom, num + 1))\n            primes: List[int] = []\n            for number in divrange:\n                if is_prime(number) and (number &gt; prime_limit):\n                    primes.append(number)\n            for prime in primes:\n                divrange.remove(prime)\n            if len(divrange) != divisor + 1:\n                factor += 1\n                i += 1\n                continue\n            else:\n                break\n\n        divrange.reverse()\n        for j, number in enumerate(divrange):\n            try:\n                divisions.append(JustInterval(number, divrange[j + 1]))\n            except IndexError:\n                continue\n\n        return sorted(divisions)\n\n    @property\n    def numerator(self) -&gt; int:\n\"\"\"JustInterval numerator.\"\"\"\n        return self._numerator\n\n    @property\n    def denominator(self) -&gt; int:\n\"\"\"JustInterval denominator.\"\"\"\n        return self._denominator\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"JustInterval prime limit.\n\n        Examples:\n            &gt;&gt;&gt; JustInterval(64, 49).prime_limit\n            7\n        \"\"\"\n        if self.base_octave == JustInterval(1, 1):\n            return 1\n        num = max(prime_factors(self.numerator))\n        denom = max(prime_factors(self.denominator))\n\n        return max(num, denom)\n\n    @property\n    def is_superparticular(self) -&gt; bool:\n\"\"\"Superparticular just intervals are of the form x+1:x\n\n        Examples:\n            &gt;&gt;&gt; JustInterval(3, 2).is_superparticular\n            True\n        \"\"\"\n        return self.numerator == self.denominator + 1\n\n    @property\n    def base_octave(self) -&gt; JustInterval:\n\"\"\"The interval within the range 1:1 to 2:1\n\n        Examples:\n            &gt;&gt;&gt; JustInterval.from_string('9:4').base_octave\n            JustInterval(9, 8)\n        \"\"\"\n        cself = deepcopy(self)\n        while cself &gt;= JustInterval(2, 1):\n            cself -= JustInterval(2, 1)\n        return cself\n\n    @property\n    def complement(self) -&gt; JustInterval:\n\"\"\"JustInterval complement.\n\n        The interval which, when added to this interval, yields an\n        octave. This only applies to intervals smaller than the octave and\n        will return `NotImplemented` if self is an interval larger than an\n        octave.\n\n        Returns:\n            The interval's complement\n\n        Note:\n            Returns a copy\n\n        Examples:\n            &gt;&gt;&gt; JustInterval(3, 2).complement\n            JustInterval(4, 3)\n        \"\"\"\n        octave = JustInterval(2, 1)\n        if self &lt; octave:\n            return octave - self\n        if self == octave:\n            return JustInterval(1, 1)\n        return NotImplemented\n\n    @property\n    def cents(self) -&gt; float:\n\"\"\"JustInterval expressed in Cents.\n\n        Returns:\n            The interval in Cents\n\n        Examples:\n            &gt;&gt;&gt; round(JustInterval(3, 2).cents, 3)\n            701.955\n        \"\"\"\n        return log(self.numerator / self.denominator, 10) * (1200 / log(2, 10))\n\n    def _prepare_division(self, number: int) -&gt; Tuple[int, int]:\n\"\"\"Helper for JustInterval division.\"\"\"\n        if not isinstance(number, int):\n            msg = \"Must be int, not {}\".format(type(number))\n            raise TypeError(msg)\n\n        if not self.is_superparticular:\n            if number % (self.numerator - self.denominator):\n                msg = \"{} is not divisible by {}\".format(self, number)\n                raise ValueError(msg)\n            factor = number // (self.numerator - self.denominator)\n            num = self.numerator * factor\n            denom = self.denominator * factor\n\n        else:\n            num = self.numerator * number\n            denom = self.denominator * number\n\n        return num, denom\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        return \"{}({}, {})\".format(\n            self.__class__.__name__, self._numerator, self.denominator\n        )\n\n    def __add__(self, other: JustInterval) -&gt; JustInterval:\n\"\"\"JustInterval addition.\n\n        Examples:\n\n        &gt;&gt;&gt; JustInterval(3, 2) + JustInterval(4, 3)\n        JustInterval(2, 1)\n        \"\"\"\n        if not isinstance(other, JustInterval):\n            other = JustInterval(other.numerator, other.denominator)\n        return JustInterval(\n            self.numerator * other.numerator, self.denominator * other.denominator\n        )\n\n    def __radd__(self, other: JustInterval) -&gt; JustInterval:\n\"\"\"JustInterval right of operator addition.\n\n        Examples:\n\n        &gt;&gt;&gt; sum((JustInterval(3, 2), JustInterval(4, 3)))\n        JustInterval(2, 1)\n        \"\"\"\n        if other == 0:\n            other = JustInterval(1, 1)\n        return self + other\n\n    def __sub__(self, other: JustInterval) -&gt; JustInterval:\n\"\"\"JustInterval substraction.\n\n        Examples:\n\n        &gt;&gt;&gt; JustInterval(3, 2) - JustInterval(9, 8)\n        JustInterval(4, 3)\n        &gt;&gt;&gt; JustInterval(1, 1) - JustInterval(3, 2)\n        JustInterval(4, 3)\n        \"\"\"\n        if other &gt; self:\n            cself = deepcopy(self)\n            cself += JustInterval(2, 1)\n            return cself - other\n        return JustInterval(\n            self.numerator * other.denominator, self.denominator * other.numerator\n        )\n\n    def __mul__(self, other):\n\"\"\"JustInterval left of operator multiplication.\"\"\"\n        return NotImplemented\n\n    def __rmul__(self, other: float) -&gt; float:\n\"\"\"JustInterval right of operator multiplication.\n\n        This is used to calculate the absolute frequency of a pitch _this_\n        interval above it.\n\n        Examples:\n\n        &gt;&gt;&gt; 440 * JustInterval(3, 2)\n        660.0\n        \"\"\"\n        try:\n            return other * (self.numerator / self.denominator)\n        except TypeError:\n            msg = \"Can't multiply sequence by non-int of type '{}'\".format(\n                self.__class__.__name__\n            )\n            raise TypeError(msg)\n\n    def __pow__(self, other: int) -&gt; JustInterval:\n\"\"\"JustInterval raised to a power. Used for chaining an interval.\n\n        Examples:\n\n        &gt;&gt;&gt; JustInterval(3, 2) ** 3\n        JustInterval(27, 8)\n        \"\"\"\n        if other &lt; 0:\n            msg = \"JustInterval can only be raised to positive powers. \"\n            msg += \"Got '{}'\".format(other)\n            raise ValueError(msg)\n        elif other == 0:\n            return JustInterval(1, 1)\n        return sum([self] * other)  # type: ignore\n\n    def __truediv__(self, other: int) -&gt; List[JustInterval]:\n\"\"\"Naive JustInterval division.\n\n        For divisions within a given prime limit, use self.divisions()\n\n        :rtype: JustInterval\n\n        Examples:\n\n        &gt;&gt;&gt; JustInterval(2, 1) / 2\n        [JustInterval(4, 3), JustInterval(3, 2)]\n        &gt;&gt;&gt; JustInterval(2, 1) / 3\n        [JustInterval(6, 5), JustInterval(5, 4), JustInterval(4, 3)]\n        &gt;&gt;&gt; JustInterval(7, 4) / 3\n        [JustInterval(7, 6), JustInterval(6, 5), JustInterval(5, 4)]\n        \"\"\"\n        num, denom = self._prepare_division(other)\n\n        return sorted([JustInterval(n, n - 1) for n in range(denom + 1, num + 1)])\n\n    def __rtruediv__(self, other):\n\"\"\"There's no sense dividing something by a JustInterval.\"\"\"\n        return NotImplemented\n\n    def _richcmp(self, other: JustInterval, oper: Callable) -&gt; bool:\n\"\"\"Helper for comparison operators, for internal use only.\"\"\"\n        return oper(\n            self.numerator / self.denominator, other.numerator / other.denominator\n        )\n\n    def __eq__(self, other: Any) -&gt; bool:\n\"\"\"self == other\"\"\"\n        if not isinstance(other, JustInterval):\n            return False\n        return self._richcmp(other, operator.eq)\n\n    def __lt__(self, other: JustInterval) -&gt; bool:\n\"\"\"self &lt; other\"\"\"\n        return self._richcmp(other, operator.lt)\n\n    def __gt__(self, other: JustInterval) -&gt; bool:\n\"\"\"self &gt; other\"\"\"\n        return self._richcmp(other, operator.gt)\n\n    def __le__(self, other: JustInterval) -&gt; bool:\n\"\"\"self &lt;= other\"\"\"\n        return self._richcmp(other, operator.le)\n\n    def __ge__(self, other: JustInterval) -&gt; bool:\n\"\"\"self &gt;= other\"\"\"\n        return self._richcmp(other, operator.ge)\n\n    def __bool__(self) -&gt; bool:\n\"\"\"self != 0\"\"\"\n        return self._numerator != 0\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.prime_limit","title":"<code>prime_limit: int</code>  <code>property</code>","text":"<p>JustInterval prime limit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval(64, 49).prime_limit\n7\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.is_superparticular","title":"<code>is_superparticular: bool</code>  <code>property</code>","text":"<p>Superparticular just intervals are of the form x+1:x</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval(3, 2).is_superparticular\nTrue\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.base_octave","title":"<code>base_octave: JustInterval</code>  <code>property</code>","text":"<p>The interval within the range 1:1 to 2:1</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval.from_string('9:4').base_octave\nJustInterval(9, 8)\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.complement","title":"<code>complement: JustInterval</code>  <code>property</code>","text":"<p>JustInterval complement.</p> <p>The interval which, when added to this interval, yields an octave. This only applies to intervals smaller than the octave and will return <code>NotImplemented</code> if self is an interval larger than an octave.</p> <p>Returns:</p> Type Description <code>JustInterval</code> <p>The interval's complement</p> Note <p>Returns a copy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval(3, 2).complement\nJustInterval(4, 3)\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.cents","title":"<code>cents: float</code>  <code>property</code>","text":"<p>JustInterval expressed in Cents.</p> <p>Returns:</p> Type Description <code>float</code> <p>The interval in Cents</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; round(JustInterval(3, 2).cents, 3)\n701.955\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.__init__","title":"<code>__init__(numerator, denominator)</code>","text":"<p>Initializes a JustInterval.</p> <p>Parameters:</p> Name Type Description Default <code>numerator</code> <code>int</code> <p>Numerator</p> required <code>denominator</code> <code>int</code> <p>Denominator</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval(4, 3)\nJustInterval(4, 3)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>def __init__(self, numerator: int, denominator: int):\n\"\"\"Initializes a JustInterval.\n\n    Parameters:\n        numerator: Numerator\n        denominator: Denominator\n\n    Examples:\n        &gt;&gt;&gt; JustInterval(4, 3)\n        JustInterval(4, 3)\n    \"\"\"\n    if not (isinstance(numerator, int) and isinstance(denominator, int)):\n        msg = \"Both components must be integers. \"\n        msg += \"Got numerator: {}, denominator: {}\".format(\n            type(numerator), type(denominator)\n        )\n        raise TypeError(msg)\n\n    if denominator &gt; numerator:\n        msg = \"Numerator must be greater than or equal to denominator. \"\n        msg += \"Got numerator: {}, denominator: {}\".format(numerator, denominator)\n        raise ValueError(msg)\n\n    if denominator == 0:\n        raise ZeroDivisionError(\"JustRatio({}, 0)\".format(numerator))\n\n    if denominator &lt; 1:\n        msg = \"Denominator must be greater than 0. \"\n        msg += \"Got: {}\".format(numerator)\n        raise ValueError(msg)\n\n    common = gcd(numerator, denominator)\n    numerator //= common\n    denominator //= common\n\n    self._numerator = numerator\n    self._denominator = denominator\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.from_string","title":"<code>from_string(interval)</code>  <code>classmethod</code>","text":"<p>Creates a JustInterval from a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>A string representation of an interval in the <code>numerator:denominator</code> format.</p> required <p>Returns:</p> Type Description <code>JustInterval</code> <p>A JustInterval</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval.from_string('3:2')\nJustInterval(3, 2)\n</code></pre> <pre><code>&gt;&gt;&gt; JustInterval.from_string('3:3')\nJustInterval(1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; JustInterval.from_string('6:3')\nJustInterval(2, 1)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>@classmethod\ndef from_string(cls, interval: str) -&gt; JustInterval:\n\"\"\"Creates a JustInterval from a string representation.\n\n    Parameters:\n        interval: A string representation of an interval in the\n            `numerator:denominator` format.\n\n    Returns:\n        A JustInterval\n\n    Examples:\n        &gt;&gt;&gt; JustInterval.from_string('3:2')\n        JustInterval(3, 2)\n\n        &gt;&gt;&gt; JustInterval.from_string('3:3')\n        JustInterval(1, 1)\n\n        &gt;&gt;&gt; JustInterval.from_string('6:3')\n        JustInterval(2, 1)\n    \"\"\"\n    re_match = _RATIO_FORMAT.match(interval)\n    if re_match is None:\n        msg = \"Invalid literal for JustRatio: {}\".format(interval)\n        raise ValueError(msg)\n    try:\n        numerator = int(re_match.group(\"num\"))\n        denominator = int(re_match.group(\"denom\"))\n        return JustInterval(numerator=numerator, denominator=denominator)\n    except ValueError:\n        msg = \"Invalid literal for JustRatio: {}\".format(interval)\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.from_two_hertz","title":"<code>from_two_hertz(apitch, bpitch)</code>  <code>classmethod</code>","text":"<p>Creates a JustInterval from two Hertz values.</p> <p>Parameters:</p> Name Type Description Default <code>apitch</code> <code>float</code> <p>A value in Hertz (which will be truncated to an int)</p> required <code>bpitch</code> <code>float</code> <p>A value in Hertz (which will be truncated to an int)</p> required <p>Returns:</p> Type Description <code>JustInterval</code> <p>A JustInterval</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval.from_two_hertz(220, 440)\nJustInterval(2, 1)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>@classmethod\ndef from_two_hertz(cls, apitch: float, bpitch: float) -&gt; JustInterval:\n\"\"\"Creates a JustInterval from two Hertz values.\n\n    Parameters:\n        apitch: A value in Hertz (which will be truncated to an int)\n        bpitch: A value in Hertz (which will be truncated to an int)\n\n    Returns:\n        A JustInterval\n\n    Examples:\n        &gt;&gt;&gt; JustInterval.from_two_hertz(220, 440)\n        JustInterval(2, 1)\n    \"\"\"\n    smaller = apitch if apitch &lt;= bpitch else bpitch\n    greater = apitch if apitch &gt; bpitch else bpitch\n\n    return cls(int(greater), int(smaller))\n</code></pre>"},{"location":"api/intervals/#jintonic.intervals.JustInterval.divisions","title":"<code>divisions(divisor, prime_limit=7, max_iterations=30)</code>","text":"<p>Divides a just interval into intervals that respect a prime limit.</p> <p>Parameters:</p> Name Type Description Default <code>divisor</code> <code>int</code> <p>Number of divisions.</p> required <code>prime_limit</code> <code>int</code> <p>The prime limit, a prime number.</p> <code>7</code> <code>max_iterations</code> <code>int</code> <p>A limit to how many divisions this method will try before giving up on dividing within the prime limit.</p> <code>30</code> <p>Returns:</p> Type Description <code>List[JustInterval]</code> <p>The resulting JustIntervals</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustInterval(2, 1).divisions(4, 5)\n[JustInterval(10, 9), JustInterval(9, 8), JustInterval(6, 5),\nJustInterval(4, 3)]\n</code></pre> <pre><code>&gt;&gt;&gt; JustInterval(16, 15).divisions(2, 31)\n[JustInterval(32, 31), JustInterval(31, 30)]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/intervals.py</code> <pre><code>def divisions(\n    self,\n    divisor: int,\n    prime_limit: int = 7,\n    max_iterations: int = 30,\n) -&gt; List[JustInterval]:\n\"\"\"Divides a just interval into intervals that respect a prime limit.\n\n    Parameters:\n        divisor: Number of divisions.\n        prime_limit: The prime limit, a prime number.\n        max_iterations: A limit to how many divisions this method will\n            try before giving up on dividing within the prime limit.\n\n    Returns:\n        The resulting JustIntervals\n\n    Examples:\n        &gt;&gt;&gt; JustInterval(2, 1).divisions(4, 5)\n        [JustInterval(10, 9), JustInterval(9, 8), JustInterval(6, 5),\n        JustInterval(4, 3)]\n\n        &gt;&gt;&gt; JustInterval(16, 15).divisions(2, 31)\n        [JustInterval(32, 31), JustInterval(31, 30)]\n    \"\"\"\n    if not is_prime(prime_limit):\n        msg = \"The prime limit must be a prime number. \"\n        msg += \"Got: '{}'\".format(prime_limit)\n        raise ValueError(msg)\n\n    factor = divisor\n    divisions: List[JustInterval] = []\n    divrange: List[int] = []\n    i = 0\n    while i &lt;= max_iterations:\n        num = self.numerator * factor\n        denom = self.denominator * factor\n\n        divrange = list(range(denom, num + 1))\n        primes: List[int] = []\n        for number in divrange:\n            if is_prime(number) and (number &gt; prime_limit):\n                primes.append(number)\n        for prime in primes:\n            divrange.remove(prime)\n        if len(divrange) != divisor + 1:\n            factor += 1\n            i += 1\n            continue\n        else:\n            break\n\n    divrange.reverse()\n    for j, number in enumerate(divrange):\n        try:\n            divisions.append(JustInterval(number, divrange[j + 1]))\n        except IndexError:\n            continue\n\n    return sorted(divisions)\n</code></pre>"},{"location":"api/lattice/","title":"lattice","text":""},{"location":"api/lattice/#justlattice","title":"JustLattice","text":"<p>This class implements just intonation lattices.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>class JustLattice:\n\"\"\"This class implements just intonation lattices.\"\"\"\n\n    def __init__(self, fundamental: float, prime_limit: int = 7):\n\"\"\"Initializes a JustLattice.\n\n        Parameters:\n            prime_limit: The prime limit. A prime number.\n            fundamental: The 1/1 pitch in Hertz\n\n        Examples:\n            &gt;&gt;&gt; JustLattice(60)\n            JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n        \"\"\"\n        self._fundamental: float = float(fundamental)\n        self._prime_limit: int = prime_limit\n\n        self._tone: JustInterval = JustInterval(1, 1)\n        self._node: List[int] = [0, 0, 0]\n        self._path: List[List[int]] = [self._node]\n\n    def traverse(self, vector: List[int]):\n\"\"\"Traverses a just intonation lattice.\n\n        Parameters:\n            vector: Number of steps along each axis. Steps are assigned to\n                an axis based on position. The first argument is on the three-limit\n                axis, the second on the five-limit, third on the seven-limit,\n                etc. To stay in place on an axis, pass 0 for that axis.\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n            JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n            &gt;&gt;&gt; lattice.traverse([-2, 0, 0])\n            JustLattice(60.0 Hz, 4/3, 80.0 Hz)\n            &gt;&gt;&gt; lattice.traverse([1, 1, 0])\n            JustLattice(60.0 Hz, 5/4, 75.0 Hz)\n            &gt;&gt;&gt; lattice.traverse([0, -2, 0])\n            JustLattice(60.0 Hz, 8/5, 96.0 Hz)\n            &gt;&gt;&gt; lattice.traverse([0, 1, 1])\n            JustLattice(60.0 Hz, 7/4, 105.0 Hz)\n            &gt;&gt;&gt; lattice.traverse([0, 0, -2])\n            JustLattice(60.0 Hz, 8/7, 68.5714 Hz)\n            &gt;&gt;&gt; lattice.traverse([2, 0, 1])\n            JustLattice(60.0 Hz, 9/8, 67.5 Hz)\n            &gt;&gt;&gt; lattice.traverse([-4, 0, 0])\n            JustLattice(60.0 Hz, 16/9, 106.6667 Hz)\n        \"\"\"\n        primary_intervals = [\n            primary_interval(prime) for prime in generate_primes(self.prime_limit)[1:]\n        ]\n        if len(vector) &gt; len(primary_intervals):\n            return NotImplemented\n\n        for axis, steps in enumerate(list(vector)):\n            interval = primary_intervals[axis] ** abs(steps)\n            if steps &gt; 0:\n                self._tone += interval\n            elif steps &lt; 0:\n                self._tone -= interval\n            else:\n                continue\n\n        self._tone = self._tone.base_octave\n        self._node = vector\n        self._path.append(vector)\n\n        return self\n\n    def undo(self, steps: int = 1):\n\"\"\"Undo a traversal.\n\n        Parameters:\n            steps: Number of steps to undo\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n            JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n            &gt;&gt;&gt; lattice.undo(1)\n            JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n        \"\"\"\n        for _ in range(steps):\n            vector = self._path.pop()\n            self.traverse([-1 * distance for distance in vector])\n\n        return self\n\n    def to_fundamental(self):\n\"\"\"Return to 1/1 without losing path history.\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n            JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n            &gt;&gt;&gt; lattice.to_fundamental()\n            JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n        \"\"\"\n        axes = len(self._node)\n        root_node = [0] * axes\n        self._node = root_node\n        self._tone = JustInterval(1, 1)\n        self._path.append(root_node)\n        self._pitch = self._fundamental\n\n        return self\n\n    def reset_path(self):\n\"\"\"Clear path history and return to 1/1.\"\"\"\n        self.to_fundamental()\n        axes = len(self._node)\n        root_node = [0] * axes\n        self._path = [root_node]\n\n        return self\n\n    def to_node(self, node: List[int]):\n\"\"\"Traverse to a specific node.\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n            JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n            &gt;&gt;&gt; lattice.to_node([0, 0, 0])\n            JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n        \"\"\"\n        self.to_fundamental()\n        self.traverse(node)\n\n        return self\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"The prime limit.\n\n        Returns:\n            The prime limit of the lattice\n\n        Examples:\n            &gt;&gt;&gt; JustLattice(60).prime_limit\n            7\n        \"\"\"\n        return self._prime_limit\n\n    @prime_limit.setter\n    def prime_limit(self, value: int):\n\"\"\"The prime limit.\n\n        Parameters:\n            value: A prime number.\n\n        Returns:\n            The prime limit of the lattice\n\n        Examples:\n            &gt;&gt;&gt; JustLattice(60).prime_limit\n            7\n        \"\"\"\n        if not is_prime(value):\n            msg = \"Prime limit must be a prime number. \"\n            msg += \"Got '{}'\".format(value)\n        self._prime_limit = value\n\n    @property\n    def fundamental(self) -&gt; float:\n\"\"\"Fundamental (1/1) pitch in Hertz.\n\n        Returns:\n            The fundamental's frequency in Hertz\n\n        Examples:\n            &gt;&gt;&gt; JustLattice(60.0).fundamental\n            60.0\n        \"\"\"\n        return self._fundamental\n\n    @fundamental.setter\n    def fundamental(self, value: float):\n\"\"\"Set the fundamental (1/1) pitch in Hertz.\"\"\"\n        try:\n            self._fundamental = float(value)\n            self._pitch = self._fundamental * self._tone\n        except ValueError:\n            msg = \"Fundamental must be numeric. Got '{}'.\".format(type(value))\n            raise ValueError(msg)\n\n    @property\n    def hertz(self) -&gt; float:\n\"\"\"Current node's pitch in Hertz.\n\n        Returns:\n            The current node's pitch in Hertz\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0]).hertz\n            90.0\n        \"\"\"\n        return self._fundamental * self._tone\n\n    @property\n    def cents(self) -&gt; float:\n\"\"\"Current node's interval in Cents.\n\n        Returns:\n            The current node's interval in Cents\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; round(lattice.traverse([1, 0, 0]).cents, 3)\n            701.955\n        \"\"\"\n        return self._tone.cents\n\n    @property\n    def tone(self) -&gt; JustInterval:\n\"\"\"Current node's tone.\n\n        Returns:\n            The current node's tone as a JustInterval\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([1, 0, 0]).tone\n            JustInterval(3, 2)\n        \"\"\"\n        return self._tone\n\n    @property\n    def node(self) -&gt; List[int]:\n\"\"\"Current node as a vector with length equivalent to number of axes.\n\n        Returns:\n            The current node as a vector with length equivalent to number of axes\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([0, 2, 3]).node\n            [0, 2, 3]\n        \"\"\"\n        return self._node\n\n    @property\n    def path(self) -&gt; List[List[int]]:\n\"\"\"Current traversal history.\n\n        Returns:\n            The traversal history across the lattice\n\n        Examples:\n            &gt;&gt;&gt; lattice = JustLattice(60)\n            &gt;&gt;&gt; lattice.traverse([0, 2, 3]).path\n            [[0, 0, 0], [0, 2, 3]]\n        \"\"\"\n        return self._path\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        return \"{}({} Hz, {}/{}, {} Hz)\".format(\n            self.__class__.__name__,\n            self.fundamental,\n            self.tone.numerator,\n            self.tone.denominator,\n            round(self.hertz, 4),\n        )\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.prime_limit","title":"<code>prime_limit: int</code>  <code>writable</code> <code>property</code>","text":"<p>The prime limit.</p> <p>Returns:</p> Type Description <code>int</code> <p>The prime limit of the lattice</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustLattice(60).prime_limit\n7\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.fundamental","title":"<code>fundamental: float</code>  <code>writable</code> <code>property</code>","text":"<p>Fundamental (1/1) pitch in Hertz.</p> <p>Returns:</p> Type Description <code>float</code> <p>The fundamental's frequency in Hertz</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustLattice(60.0).fundamental\n60.0\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.hertz","title":"<code>hertz: float</code>  <code>property</code>","text":"<p>Current node's pitch in Hertz.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current node's pitch in Hertz</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0]).hertz\n90.0\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.cents","title":"<code>cents: float</code>  <code>property</code>","text":"<p>Current node's interval in Cents.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current node's interval in Cents</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; round(lattice.traverse([1, 0, 0]).cents, 3)\n701.955\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.tone","title":"<code>tone: JustInterval</code>  <code>property</code>","text":"<p>Current node's tone.</p> <p>Returns:</p> Type Description <code>JustInterval</code> <p>The current node's tone as a JustInterval</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0]).tone\nJustInterval(3, 2)\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.node","title":"<code>node: List[int]</code>  <code>property</code>","text":"<p>Current node as a vector with length equivalent to number of axes.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The current node as a vector with length equivalent to number of axes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([0, 2, 3]).node\n[0, 2, 3]\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.path","title":"<code>path: List[List[int]]</code>  <code>property</code>","text":"<p>Current traversal history.</p> <p>Returns:</p> Type Description <code>List[List[int]]</code> <p>The traversal history across the lattice</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([0, 2, 3]).path\n[[0, 0, 0], [0, 2, 3]]\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.__init__","title":"<code>__init__(fundamental, prime_limit=7)</code>","text":"<p>Initializes a JustLattice.</p> <p>Parameters:</p> Name Type Description Default <code>prime_limit</code> <code>int</code> <p>The prime limit. A prime number.</p> <code>7</code> <code>fundamental</code> <code>float</code> <p>The 1/1 pitch in Hertz</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustLattice(60)\nJustLattice(60.0 Hz, 1/1, 60.0 Hz)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def __init__(self, fundamental: float, prime_limit: int = 7):\n\"\"\"Initializes a JustLattice.\n\n    Parameters:\n        prime_limit: The prime limit. A prime number.\n        fundamental: The 1/1 pitch in Hertz\n\n    Examples:\n        &gt;&gt;&gt; JustLattice(60)\n        JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n    \"\"\"\n    self._fundamental: float = float(fundamental)\n    self._prime_limit: int = prime_limit\n\n    self._tone: JustInterval = JustInterval(1, 1)\n    self._node: List[int] = [0, 0, 0]\n    self._path: List[List[int]] = [self._node]\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.traverse","title":"<code>traverse(vector)</code>","text":"<p>Traverses a just intonation lattice.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>List[int]</code> <p>Number of steps along each axis. Steps are assigned to an axis based on position. The first argument is on the three-limit axis, the second on the five-limit, third on the seven-limit, etc. To stay in place on an axis, pass 0 for that axis.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0])\nJustLattice(60.0 Hz, 3/2, 90.0 Hz)\n&gt;&gt;&gt; lattice.traverse([-2, 0, 0])\nJustLattice(60.0 Hz, 4/3, 80.0 Hz)\n&gt;&gt;&gt; lattice.traverse([1, 1, 0])\nJustLattice(60.0 Hz, 5/4, 75.0 Hz)\n&gt;&gt;&gt; lattice.traverse([0, -2, 0])\nJustLattice(60.0 Hz, 8/5, 96.0 Hz)\n&gt;&gt;&gt; lattice.traverse([0, 1, 1])\nJustLattice(60.0 Hz, 7/4, 105.0 Hz)\n&gt;&gt;&gt; lattice.traverse([0, 0, -2])\nJustLattice(60.0 Hz, 8/7, 68.5714 Hz)\n&gt;&gt;&gt; lattice.traverse([2, 0, 1])\nJustLattice(60.0 Hz, 9/8, 67.5 Hz)\n&gt;&gt;&gt; lattice.traverse([-4, 0, 0])\nJustLattice(60.0 Hz, 16/9, 106.6667 Hz)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def traverse(self, vector: List[int]):\n\"\"\"Traverses a just intonation lattice.\n\n    Parameters:\n        vector: Number of steps along each axis. Steps are assigned to\n            an axis based on position. The first argument is on the three-limit\n            axis, the second on the five-limit, third on the seven-limit,\n            etc. To stay in place on an axis, pass 0 for that axis.\n\n    Examples:\n        &gt;&gt;&gt; lattice = JustLattice(60)\n        &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n        JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n        &gt;&gt;&gt; lattice.traverse([-2, 0, 0])\n        JustLattice(60.0 Hz, 4/3, 80.0 Hz)\n        &gt;&gt;&gt; lattice.traverse([1, 1, 0])\n        JustLattice(60.0 Hz, 5/4, 75.0 Hz)\n        &gt;&gt;&gt; lattice.traverse([0, -2, 0])\n        JustLattice(60.0 Hz, 8/5, 96.0 Hz)\n        &gt;&gt;&gt; lattice.traverse([0, 1, 1])\n        JustLattice(60.0 Hz, 7/4, 105.0 Hz)\n        &gt;&gt;&gt; lattice.traverse([0, 0, -2])\n        JustLattice(60.0 Hz, 8/7, 68.5714 Hz)\n        &gt;&gt;&gt; lattice.traverse([2, 0, 1])\n        JustLattice(60.0 Hz, 9/8, 67.5 Hz)\n        &gt;&gt;&gt; lattice.traverse([-4, 0, 0])\n        JustLattice(60.0 Hz, 16/9, 106.6667 Hz)\n    \"\"\"\n    primary_intervals = [\n        primary_interval(prime) for prime in generate_primes(self.prime_limit)[1:]\n    ]\n    if len(vector) &gt; len(primary_intervals):\n        return NotImplemented\n\n    for axis, steps in enumerate(list(vector)):\n        interval = primary_intervals[axis] ** abs(steps)\n        if steps &gt; 0:\n            self._tone += interval\n        elif steps &lt; 0:\n            self._tone -= interval\n        else:\n            continue\n\n    self._tone = self._tone.base_octave\n    self._node = vector\n    self._path.append(vector)\n\n    return self\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.to_fundamental","title":"<code>to_fundamental()</code>","text":"<p>Return to 1/1 without losing path history.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0])\nJustLattice(60.0 Hz, 3/2, 90.0 Hz)\n&gt;&gt;&gt; lattice.to_fundamental()\nJustLattice(60.0 Hz, 1/1, 60.0 Hz)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def to_fundamental(self):\n\"\"\"Return to 1/1 without losing path history.\n\n    Examples:\n        &gt;&gt;&gt; lattice = JustLattice(60)\n        &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n        JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n        &gt;&gt;&gt; lattice.to_fundamental()\n        JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n    \"\"\"\n    axes = len(self._node)\n    root_node = [0] * axes\n    self._node = root_node\n    self._tone = JustInterval(1, 1)\n    self._path.append(root_node)\n    self._pitch = self._fundamental\n\n    return self\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.to_node","title":"<code>to_node(node)</code>","text":"<p>Traverse to a specific node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0])\nJustLattice(60.0 Hz, 3/2, 90.0 Hz)\n&gt;&gt;&gt; lattice.to_node([0, 0, 0])\nJustLattice(60.0 Hz, 1/1, 60.0 Hz)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def to_node(self, node: List[int]):\n\"\"\"Traverse to a specific node.\n\n    Examples:\n        &gt;&gt;&gt; lattice = JustLattice(60)\n        &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n        JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n        &gt;&gt;&gt; lattice.to_node([0, 0, 0])\n        JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n    \"\"\"\n    self.to_fundamental()\n    self.traverse(node)\n\n    return self\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.undo","title":"<code>undo(steps=1)</code>","text":"<p>Undo a traversal.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>int</code> <p>Number of steps to undo</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lattice = JustLattice(60)\n&gt;&gt;&gt; lattice.traverse([1, 0, 0])\nJustLattice(60.0 Hz, 3/2, 90.0 Hz)\n&gt;&gt;&gt; lattice.undo(1)\nJustLattice(60.0 Hz, 1/1, 60.0 Hz)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def undo(self, steps: int = 1):\n\"\"\"Undo a traversal.\n\n    Parameters:\n        steps: Number of steps to undo\n\n    Examples:\n        &gt;&gt;&gt; lattice = JustLattice(60)\n        &gt;&gt;&gt; lattice.traverse([1, 0, 0])\n        JustLattice(60.0 Hz, 3/2, 90.0 Hz)\n        &gt;&gt;&gt; lattice.undo(1)\n        JustLattice(60.0 Hz, 1/1, 60.0 Hz)\n    \"\"\"\n    for _ in range(steps):\n        vector = self._path.pop()\n        self.traverse([-1 * distance for distance in vector])\n\n    return self\n</code></pre>"},{"location":"api/lattice/#jintonic.lattice.JustLattice.reset_path","title":"<code>reset_path()</code>","text":"<p>Clear path history and return to 1/1.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/lattice.py</code> <pre><code>def reset_path(self):\n\"\"\"Clear path history and return to 1/1.\"\"\"\n    self.to_fundamental()\n    axes = len(self._node)\n    root_node = [0] * axes\n    self._path = [root_node]\n\n    return self\n</code></pre>"},{"location":"api/primes/","title":"primes","text":""},{"location":"api/primes/#jintonic.primes.is_prime","title":"<code>is_prime(number)</code>","text":"<p>States if a number is prime.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>A number</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the number is prime</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_prime(31)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; is_prime(42)\nFalse\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/primes.py</code> <pre><code>def is_prime(number: int) -&gt; bool:\n\"\"\"States if a number is prime.\n\n    Parameters:\n        number: A number\n\n    Returns:\n        Whether or not the number is prime\n\n    Examples:\n        &gt;&gt;&gt; is_prime(31)\n        True\n\n        &gt;&gt;&gt; is_prime(42)\n        False\n    \"\"\"\n    for factor in range(2, number):\n        if not number % factor:\n            return False\n    return True\n</code></pre>"},{"location":"api/primes/#jintonic.primes.generate_primes","title":"<code>generate_primes(limit)</code>","text":"<p>Generates primes up to a given limit.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The limit.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>Primes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_primes(31)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/primes.py</code> <pre><code>def generate_primes(limit: int) -&gt; List[int]:\n\"\"\"Generates primes up to a given limit.\n\n    Parameters:\n        limit: The limit.\n\n    Returns:\n        Primes\n\n    Examples:\n        &gt;&gt;&gt; generate_primes(31)\n        [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    \"\"\"\n    return [n for n in range(2, limit + 1) if is_prime(n)]\n</code></pre>"},{"location":"api/primes/#jintonic.primes.prime_factors","title":"<code>prime_factors(number)</code>","text":"<p>Finds prime factors of an integer (by trial-division).</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer to factor</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>Prime factors</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prime_factors(314)\n[2, 157]\n</code></pre> <pre><code>&gt;&gt;&gt; prime_factors(31)\n[31]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/primes.py</code> <pre><code>def prime_factors(number: int) -&gt; List[int]:\n\"\"\"Finds prime factors of an integer (by trial-division).\n\n    Parameters:\n        number: The integer to factor\n\n    Returns:\n        Prime factors\n\n    Examples:\n        &gt;&gt;&gt; prime_factors(314)\n        [2, 157]\n\n        &gt;&gt;&gt; prime_factors(31)\n        [31]\n    \"\"\"\n    factor = 2\n    factors = []\n    while factor * factor &lt;= number:\n        if number % factor:\n            factor += 1\n        else:\n            number //= factor\n            factors.append(factor)\n    if number &gt; 1:\n        factors.append(number)\n\n    return factors\n</code></pre>"},{"location":"api/primes/#jintonic.primes.lcm","title":"<code>lcm(numbers)</code>","text":"<p>Least common multiple of a list of integers.</p> <p>Parameters:</p> Name Type Description Default <code>numbers</code> <code>List[int]</code> <p>List of integers</p> required <p>Returns:</p> Type Description <code>int</code> <p>Least common multiple</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lcm([15, 3, 5])\n15\n</code></pre> <pre><code>&gt;&gt;&gt; lcm([21, 6, 7])\n42\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/primes.py</code> <pre><code>def lcm(numbers: List[int]) -&gt; int:\n\"\"\"Least common multiple of a list of integers.\n\n    Parameters:\n        numbers: List of integers\n\n    Returns:\n        Least common multiple\n\n    Examples:\n        &gt;&gt;&gt; lcm([15, 3, 5])\n        15\n\n        &gt;&gt;&gt; lcm([21, 6, 7])\n        42\n    \"\"\"\n    return reduce(lambda x, y: x * y // gcd(x, y), numbers)\n</code></pre>"},{"location":"api/scales/","title":"scales","text":""},{"location":"api/scales/#justscale","title":"JustScale","text":"<p>This class implements arbitrary just intonation scales.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>class JustScale:\n\"\"\"This class implements arbitrary just intonation scales.\"\"\"\n\n    def __init__(self, tones: List[JustInterval]):\n\"\"\"Initializes a JustScale.\n\n        Parameters:\n            tones: A list of intervals or an object containing a list of\n                intervals (that implements the attribute intervals)\n\n        Examples:\n            &gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n            &gt;&gt;&gt; scale.append(JustInterval(3, 2))\n            &gt;&gt;&gt; scale.append(JustInterval(2, 1))\n            &gt;&gt;&gt; scale\n            JustScale([1/1, 3/2, 2/1])\n        \"\"\"\n        self._tones = tones\n\n    def append(self, tone: JustInterval):\n\"\"\"Appends tones to the scale.\n\n        Parameters:\n            tone: A new tone\n\n        Examples:\n            &gt;&gt;&gt; scale = JustScale([JustInterval(3, 2)])\n            &gt;&gt;&gt; scale.append(JustInterval(4, 3))\n            &gt;&gt;&gt; scale.tones\n            [JustInterval(4, 3), JustInterval(3, 2)]\n        \"\"\"\n        if not isinstance(tone, JustInterval):\n            msg = \"cannot append type {}. \".format(type(tone))\n            msg += 'Expecting type \"JustInterval\"'\n            raise ValueError(msg)\n        self._tones.append(tone)\n\n    def hertz(self, fundamental: float) -&gt; List[float]:\n\"\"\"Translates scale intervals to pitches in Hertz over a fundamental\n\n        Note:\n            Here, the fundamental is always 1/1 and is not to be mistaken with\n            the first tone of the scale. If 1/1 is not part of the scale's\n            tones, the fundamental will not be part of the scale.\n\n        Parameters:\n            fundamental: The scale's 0 degree (fundamental) pitch in Hertz.\n\n        Returns:\n            Scale pitches as Hertz\n        \"\"\"\n        return [fundamental * tone for tone in self.tones]\n\n    @property\n    def tones(self) -&gt; List[JustInterval]:\n\"\"\"JustScale tones.\n\n        Returns:\n            Scale tones\n        \"\"\"\n        return sorted(self._tones)\n\n    @tones.setter\n    def tones(self, values: List[JustInterval]):\n\"\"\"Sets JustScale tones.\n\n        Parameters:\n            values: A list of tones\n        \"\"\"\n        for tone in values:\n            if not isinstance(tone, JustInterval):\n                msg = \"tones must be a list of JustIntervals. \"\n                msg += \"Got '{}'\".format(values)\n                raise ValueError(msg)\n        self._tones = values\n\n    @property\n    def intervals(self) -&gt; List[JustInterval]:\n\"\"\"JustScale intervals.\n\n        Returns:\n            Scale intervals\n\n        Examples:\n            &gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n            &gt;&gt;&gt; scale.append(JustInterval(3, 2))\n            &gt;&gt;&gt; scale.append(JustInterval(2, 1))\n            &gt;&gt;&gt; scale.intervals\n            [JustInterval(3, 2), JustInterval(4, 3)]\n        \"\"\"\n        return [tone - self.tones[i - 1] for i, tone in enumerate(self.tones)][1:]\n\n    @property\n    def complement(self) -&gt; JustScale:\n\"\"\"JustScale complement\n\n        Returns:\n            The complement scale\n\n        Examples:\n            &gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n            &gt;&gt;&gt; scale.append(JustInterval(3, 2))\n            &gt;&gt;&gt; scale.append(JustInterval(2, 1))\n            &gt;&gt;&gt; scale.complement\n            JustScale([1/1, 4/3, 2/1])\n        \"\"\"\n        tones = [tone.complement for tone in self.tones]\n        return JustScale(tones)\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"JustScale prime limit\"\"\"\n        return max([tone.prime_limit for tone in self.tones])\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        pitches = \", \".join(\n            [\n                \"/\".join([str(tone.numerator), str(tone.denominator)])\n                for tone in self.tones\n            ]\n        )\n        return \"{}([{}])\".format(self.__class__.__name__, pitches)\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustScale.tones","title":"<code>tones: List[JustInterval]</code>  <code>writable</code> <code>property</code>","text":"<p>JustScale tones.</p> <p>Returns:</p> Type Description <code>List[JustInterval]</code> <p>Scale tones</p>"},{"location":"api/scales/#jintonic.scales.JustScale.intervals","title":"<code>intervals: List[JustInterval]</code>  <code>property</code>","text":"<p>JustScale intervals.</p> <p>Returns:</p> Type Description <code>List[JustInterval]</code> <p>Scale intervals</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n&gt;&gt;&gt; scale.append(JustInterval(3, 2))\n&gt;&gt;&gt; scale.append(JustInterval(2, 1))\n&gt;&gt;&gt; scale.intervals\n[JustInterval(3, 2), JustInterval(4, 3)]\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustScale.complement","title":"<code>complement: JustScale</code>  <code>property</code>","text":"<p>JustScale complement</p> <p>Returns:</p> Type Description <code>JustScale</code> <p>The complement scale</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n&gt;&gt;&gt; scale.append(JustInterval(3, 2))\n&gt;&gt;&gt; scale.append(JustInterval(2, 1))\n&gt;&gt;&gt; scale.complement\nJustScale([1/1, 4/3, 2/1])\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustScale.prime_limit","title":"<code>prime_limit: int</code>  <code>property</code>","text":"<p>JustScale prime limit</p>"},{"location":"api/scales/#jintonic.scales.JustScale.__init__","title":"<code>__init__(tones)</code>","text":"<p>Initializes a JustScale.</p> <p>Parameters:</p> Name Type Description Default <code>tones</code> <code>List[JustInterval]</code> <p>A list of intervals or an object containing a list of intervals (that implements the attribute intervals)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n&gt;&gt;&gt; scale.append(JustInterval(3, 2))\n&gt;&gt;&gt; scale.append(JustInterval(2, 1))\n&gt;&gt;&gt; scale\nJustScale([1/1, 3/2, 2/1])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def __init__(self, tones: List[JustInterval]):\n\"\"\"Initializes a JustScale.\n\n    Parameters:\n        tones: A list of intervals or an object containing a list of\n            intervals (that implements the attribute intervals)\n\n    Examples:\n        &gt;&gt;&gt; scale = JustScale([JustInterval(1, 1)])\n        &gt;&gt;&gt; scale.append(JustInterval(3, 2))\n        &gt;&gt;&gt; scale.append(JustInterval(2, 1))\n        &gt;&gt;&gt; scale\n        JustScale([1/1, 3/2, 2/1])\n    \"\"\"\n    self._tones = tones\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustScale.append","title":"<code>append(tone)</code>","text":"<p>Appends tones to the scale.</p> <p>Parameters:</p> Name Type Description Default <code>tone</code> <code>JustInterval</code> <p>A new tone</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; scale = JustScale([JustInterval(3, 2)])\n&gt;&gt;&gt; scale.append(JustInterval(4, 3))\n&gt;&gt;&gt; scale.tones\n[JustInterval(4, 3), JustInterval(3, 2)]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def append(self, tone: JustInterval):\n\"\"\"Appends tones to the scale.\n\n    Parameters:\n        tone: A new tone\n\n    Examples:\n        &gt;&gt;&gt; scale = JustScale([JustInterval(3, 2)])\n        &gt;&gt;&gt; scale.append(JustInterval(4, 3))\n        &gt;&gt;&gt; scale.tones\n        [JustInterval(4, 3), JustInterval(3, 2)]\n    \"\"\"\n    if not isinstance(tone, JustInterval):\n        msg = \"cannot append type {}. \".format(type(tone))\n        msg += 'Expecting type \"JustInterval\"'\n        raise ValueError(msg)\n    self._tones.append(tone)\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustScale.hertz","title":"<code>hertz(fundamental)</code>","text":"<p>Translates scale intervals to pitches in Hertz over a fundamental</p> Note <p>Here, the fundamental is always 1/1 and is not to be mistaken with the first tone of the scale. If 1/1 is not part of the scale's tones, the fundamental will not be part of the scale.</p> <p>Parameters:</p> Name Type Description Default <code>fundamental</code> <code>float</code> <p>The scale's 0 degree (fundamental) pitch in Hertz.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>Scale pitches as Hertz</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def hertz(self, fundamental: float) -&gt; List[float]:\n\"\"\"Translates scale intervals to pitches in Hertz over a fundamental\n\n    Note:\n        Here, the fundamental is always 1/1 and is not to be mistaken with\n        the first tone of the scale. If 1/1 is not part of the scale's\n        tones, the fundamental will not be part of the scale.\n\n    Parameters:\n        fundamental: The scale's 0 degree (fundamental) pitch in Hertz.\n\n    Returns:\n        Scale pitches as Hertz\n    \"\"\"\n    return [fundamental * tone for tone in self.tones]\n</code></pre>"},{"location":"api/scales/#justtetrachord","title":"JustTetrachord","text":"<p>This class implements disjunct just intonation tetrachords.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>class JustTetrachord:\n\"\"\"This class implements disjunct just intonation tetrachords.\"\"\"\n\n    def __init__(\n        self,\n        intervals: Optional[List[JustInterval]] = None,\n        genus: Optional[str] = None,\n        prime_limit: int = 7,\n    ):\n\"\"\"Initializes a JustTetrachord.\n\n        A JustTetrachord can be constructed in one of two ways :\n\n            - from a genus name (with naive division)\n            - from a list of intervals between each successive tone\n\n        Parameters:\n            intervals: A list of intervals\n            genus: One of 'enharmonic', 'chromatic', or 'diatonic'\n            prime_limit: The prime limit to respect\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachord(genus='chromatic')\n            JustTetrachord('chromatic' [27:28, 14:15, 5:6])\n\n            &gt;&gt;&gt; JustTetrachord(genus='enharmonic')\n            JustTetrachord('enharmonic' [45:46, 23:24, 4:5])\n            &gt;&gt;&gt; JustTetrachord(genus='enharmonic').prime_limit\n            23\n\n            &gt;&gt;&gt; intervals = []\n            &gt;&gt;&gt; intervals.append(JustInterval(32, 31))\n            &gt;&gt;&gt; intervals.append(JustInterval(31, 30))\n            &gt;&gt;&gt; intervals.append(JustInterval(5, 4))\n            &gt;&gt;&gt; JustTetrachord(intervals)\n            JustTetrachord('enharmonic' [31:32, 30:31, 4:5])\n            &gt;&gt;&gt; JustTetrachord(intervals).prime_limit\n            31\n        \"\"\"\n        if not is_prime(prime_limit):\n            msg = \"The prime limit must be a prime number. \"\n            msg += \"Got: '{}'\".format(prime_limit)\n            raise ValueError(msg)\n        self._prime_limit = prime_limit\n\n        if intervals is not None:\n            self.intervals = intervals\n        elif genus is not None:\n            self.genus = genus.strip().lower()\n        else:\n            self._intervals: List[JustInterval] = []\n\n    @classmethod\n    def validate_tetrachord(cls, tetrachord: Union[JustTetrachord, List[JustInterval]]):\n\"\"\"Validates a tetrachord.\n\n        Parameters:\n            tetrachord: The tetrachord to validate\n\n        Raises:\n            ValueError: If the given tetrachord is invalid\n        \"\"\"\n        if len(tetrachord) != 3:\n            msg = \"Tetrachords must be formed of exactly three intervals. \"\n            msg += 'Got: \"{}\"'.format(tetrachord)\n            raise ValueError(msg)\n        # TODO implement __add__ and __radd__ to avoid needing these sum loops\n        total_interval = JustInterval(1, 1)\n        if isinstance(tetrachord, JustTetrachord):\n            for interval in tetrachord.intervals:\n                total_interval += interval\n        else:\n            for interval in tetrachord:\n                total_interval += interval\n        if total_interval != JustInterval(4, 3):\n            msg = \"Tetrachord intervals must sum to JustInterval(4, 3). \"\n            msg += 'Got: \"{}\"'.format(total_interval)\n            raise ValueError(msg)\n\n    @property\n    def intervals(self) -&gt; List[JustInterval]:\n\"\"\"JustTetrachord intervals.\n        Returns:\n            The tetrachord's intervals\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachord(genus='enharmonic').intervals\n            [JustInterval(46, 45), JustInterval(24, 23), JustInterval(5, 4)]\n        \"\"\"\n        return self._intervals\n\n    @intervals.setter\n    def intervals(self, values):\n\"\"\"Set JustTetrachord intervals.\n\n        Parameters:\n            value: A list of exactly three intervals which sum to 4:3\n        \"\"\"\n        self.validate_tetrachord(values)\n        self._prime_limit = max(\n            values[0].prime_limit, values[1].prime_limit, values[2].prime_limit\n        )\n        self._intervals = values\n\n    @property\n    def genus(self) -&gt; str:\n\"\"\"JustTetrachord genus.\"\"\"\n        if not self.intervals:\n            raise ValueError(\"Undefined intervals\")\n        end_intervals = [JustInterval(5, 4), JustInterval(6, 5), JustInterval(10, 9)]\n        genera = [\"enharmonic\", \"chromatic\", \"diatonic\"]\n        try:\n            return genera[end_intervals.index(self.intervals[-1])]\n        except ValueError:\n            return \"non-classical\"\n\n    @genus.setter\n    def genus(self, value: str):\n\"\"\"Set JustTetrachord genus.\n\n        Note:\n            When setting the genus, the movable tone is set to its most basic\n            position by dividing by two the interval remaining after taking the\n            characteristic interval.\n\n        Parameters:\n            value: A valid classical genus from ['enharmonic', 'chromatic', 'diatonic']\n        \"\"\"\n        characteristic_intervals = {\n            \"enharmonic\": JustInterval(5, 4),\n            \"chromatic\": JustInterval(6, 5),\n            \"diatonic\": JustInterval(10, 9),\n        }\n        characteristic = characteristic_intervals[value]\n        remainder = JustInterval(4, 3) - characteristic\n        intervals = remainder.divisions(2, self.prime_limit)\n        intervals.append(characteristic)\n        self.intervals = intervals\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"JustTetrachord prime limit.\"\"\"\n        return self._prime_limit\n\n    @property\n    def permutations(self) -&gt; List[JustTetrachord]:\n\"\"\"All (there are six) possible permutations of the JustTetrachord.\n\n        Returns:\n            The permutations of the JustTetrachord\n        \"\"\"\n        return [\n            JustTetrachord(intervals=list(permutation))\n            for permutation in permutations(self.intervals)\n        ]\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        return \"{}('{}' [{}:{}, {}:{}, {}:{}])\".format(\n            self.__class__.__name__,\n            self.genus,\n            self.intervals[0].denominator,\n            self.intervals[0].numerator,\n            self.intervals[1].denominator,\n            self.intervals[1].numerator,\n            self.intervals[2].denominator,\n            self.intervals[2].numerator,\n        )\n\n    def __eq__(self, other):\n\"\"\"self == other\"\"\"\n        return self.intervals == other.intervals\n\n    def __len__(self):\n\"\"\"len(self)\"\"\"\n        return len(self.intervals)\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.intervals","title":"<code>intervals: List[JustInterval]</code>  <code>writable</code> <code>property</code>","text":"<p>JustTetrachord intervals.</p> <p>Returns:</p> Type Description <code>List[JustInterval]</code> <p>The tetrachord's intervals</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachord(genus='enharmonic').intervals\n[JustInterval(46, 45), JustInterval(24, 23), JustInterval(5, 4)]\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.genus","title":"<code>genus: str</code>  <code>writable</code> <code>property</code>","text":"<p>JustTetrachord genus.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.prime_limit","title":"<code>prime_limit: int</code>  <code>property</code>","text":"<p>JustTetrachord prime limit.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.permutations","title":"<code>permutations: List[JustTetrachord]</code>  <code>property</code>","text":"<p>All (there are six) possible permutations of the JustTetrachord.</p> <p>Returns:</p> Type Description <code>List[JustTetrachord]</code> <p>The permutations of the JustTetrachord</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.__init__","title":"<code>__init__(intervals=None, genus=None, prime_limit=7)</code>","text":"<p>Initializes a JustTetrachord.</p> A JustTetrachord can be constructed in one of two ways <ul> <li>from a genus name (with naive division)</li> <li>from a list of intervals between each successive tone</li> </ul> <p>Parameters:</p> Name Type Description Default <code>intervals</code> <code>Optional[List[JustInterval]]</code> <p>A list of intervals</p> <code>None</code> <code>genus</code> <code>Optional[str]</code> <p>One of 'enharmonic', 'chromatic', or 'diatonic'</p> <code>None</code> <code>prime_limit</code> <code>int</code> <p>The prime limit to respect</p> <code>7</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachord(genus='chromatic')\nJustTetrachord('chromatic' [27:28, 14:15, 5:6])\n</code></pre> <pre><code>&gt;&gt;&gt; JustTetrachord(genus='enharmonic')\nJustTetrachord('enharmonic' [45:46, 23:24, 4:5])\n&gt;&gt;&gt; JustTetrachord(genus='enharmonic').prime_limit\n23\n</code></pre> <pre><code>&gt;&gt;&gt; intervals = []\n&gt;&gt;&gt; intervals.append(JustInterval(32, 31))\n&gt;&gt;&gt; intervals.append(JustInterval(31, 30))\n&gt;&gt;&gt; intervals.append(JustInterval(5, 4))\n&gt;&gt;&gt; JustTetrachord(intervals)\nJustTetrachord('enharmonic' [31:32, 30:31, 4:5])\n&gt;&gt;&gt; JustTetrachord(intervals).prime_limit\n31\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def __init__(\n    self,\n    intervals: Optional[List[JustInterval]] = None,\n    genus: Optional[str] = None,\n    prime_limit: int = 7,\n):\n\"\"\"Initializes a JustTetrachord.\n\n    A JustTetrachord can be constructed in one of two ways :\n\n        - from a genus name (with naive division)\n        - from a list of intervals between each successive tone\n\n    Parameters:\n        intervals: A list of intervals\n        genus: One of 'enharmonic', 'chromatic', or 'diatonic'\n        prime_limit: The prime limit to respect\n\n    Examples:\n        &gt;&gt;&gt; JustTetrachord(genus='chromatic')\n        JustTetrachord('chromatic' [27:28, 14:15, 5:6])\n\n        &gt;&gt;&gt; JustTetrachord(genus='enharmonic')\n        JustTetrachord('enharmonic' [45:46, 23:24, 4:5])\n        &gt;&gt;&gt; JustTetrachord(genus='enharmonic').prime_limit\n        23\n\n        &gt;&gt;&gt; intervals = []\n        &gt;&gt;&gt; intervals.append(JustInterval(32, 31))\n        &gt;&gt;&gt; intervals.append(JustInterval(31, 30))\n        &gt;&gt;&gt; intervals.append(JustInterval(5, 4))\n        &gt;&gt;&gt; JustTetrachord(intervals)\n        JustTetrachord('enharmonic' [31:32, 30:31, 4:5])\n        &gt;&gt;&gt; JustTetrachord(intervals).prime_limit\n        31\n    \"\"\"\n    if not is_prime(prime_limit):\n        msg = \"The prime limit must be a prime number. \"\n        msg += \"Got: '{}'\".format(prime_limit)\n        raise ValueError(msg)\n    self._prime_limit = prime_limit\n\n    if intervals is not None:\n        self.intervals = intervals\n    elif genus is not None:\n        self.genus = genus.strip().lower()\n    else:\n        self._intervals: List[JustInterval] = []\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachord.validate_tetrachord","title":"<code>validate_tetrachord(tetrachord)</code>  <code>classmethod</code>","text":"<p>Validates a tetrachord.</p> <p>Parameters:</p> Name Type Description Default <code>tetrachord</code> <code>Union[JustTetrachord, List[JustInterval]]</code> <p>The tetrachord to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given tetrachord is invalid</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>@classmethod\ndef validate_tetrachord(cls, tetrachord: Union[JustTetrachord, List[JustInterval]]):\n\"\"\"Validates a tetrachord.\n\n    Parameters:\n        tetrachord: The tetrachord to validate\n\n    Raises:\n        ValueError: If the given tetrachord is invalid\n    \"\"\"\n    if len(tetrachord) != 3:\n        msg = \"Tetrachords must be formed of exactly three intervals. \"\n        msg += 'Got: \"{}\"'.format(tetrachord)\n        raise ValueError(msg)\n    # TODO implement __add__ and __radd__ to avoid needing these sum loops\n    total_interval = JustInterval(1, 1)\n    if isinstance(tetrachord, JustTetrachord):\n        for interval in tetrachord.intervals:\n            total_interval += interval\n    else:\n        for interval in tetrachord:\n            total_interval += interval\n    if total_interval != JustInterval(4, 3):\n        msg = \"Tetrachord intervals must sum to JustInterval(4, 3). \"\n        msg += 'Got: \"{}\"'.format(total_interval)\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/scales/#justtetrachordalscale","title":"JustTetrachordalScale","text":"<p>This class implements disjunct just intonation tetrachordal scales.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>class JustTetrachordalScale:\n\"\"\"This class implements disjunct just intonation tetrachordal scales.\"\"\"\n\n    def __init__(\n        self,\n        lower: JustTetrachord,\n        upper: Optional[JustTetrachord] = None,\n    ):\n\"\"\"Initializes a JustTetrachordalScale.\n\n        Parameters:\n            lower: The lower tetrachord\n            upper: The upper tetrachord. If None is passed, the lower tetrachord\n                is also used for the upper, creating an 'equal' tetrachordal scale.\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='enharmonic'))\n            JustTetrachordalScale([46/45, 24/23, 5/4, 9/8, 46/45, 24/23, 5/4])\n        \"\"\"\n\n        self._lower = lower\n        if upper is None:\n            self._upper = lower\n        else:\n            self._upper = upper\n\n    @property\n    def lower(self) -&gt; JustTetrachord:\n\"\"\"Lower JustTetrachord.\"\"\"\n        return self._lower\n\n    @lower.setter\n    def lower(self, value: JustTetrachord):\n\"\"\"Set lower JustTetrachord.\"\"\"\n        JustTetrachord.validate_tetrachord(value)\n        self._lower = value\n\n    @property\n    def upper(self) -&gt; JustTetrachord:\n\"\"\"Upper JustTetrachord.\"\"\"\n        return self._upper\n\n    @upper.setter\n    def upper(self, value: JustTetrachord):\n\"\"\"Set upper JustTetrachord.\"\"\"\n        JustTetrachord.validate_tetrachord(value)\n        self._upper = value\n\n    @property\n    def intervals(self) -&gt; List[JustInterval]:\n\"\"\"JustTetrachordalScale intervals.\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).intervals\n            [JustInterval(16, 15), JustInterval(9, 8), JustInterval(10, 9),\n            JustInterval(9, 8), JustInterval(16, 15), JustInterval(9, 8),\n            JustInterval(10, 9)]\n        \"\"\"\n        return self.lower.intervals + [JustInterval(9, 8)] + self.upper.intervals\n\n    @property\n    def complement(self) -&gt; JustScale:\n\"\"\"JustTetrachordalScale complement\n\n        Note:\n            Returns a JustScale! The result will not be Tetrachordal.\n\n        Returns:\n            The JustScale that is the complement\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='chromatic')).complement\n            JustScale([1/1, 6/5, 9/7, 4/3, 3/2, 9/5, 27/14, 2/1])\n        \"\"\"\n        tones = [tone.complement for tone in self.tones]\n        return JustScale(tones)\n\n    @property\n    def tones(self) -&gt; List[JustInterval]:\n\"\"\"JustTetrachordalScale tones.\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).tones\n            [JustInterval(1, 1), JustInterval(16, 15), JustInterval(6, 5),\n            JustInterval(4, 3), JustInterval(3, 2), JustInterval(8, 5),\n            JustInterval(9, 5), JustInterval(2, 1)]\n        \"\"\"\n        tones = [JustInterval(1, 1)]\n        tones += [\n            sum(self.intervals[:i], start=JustInterval(1, 1))\n            for i in range(1, len(self.intervals))\n        ]\n        tones += [JustInterval(2, 1)]\n        return tones\n\n    def hertz(self, fundamental: float) -&gt; List[float]:\n\"\"\"Translates scale intervals to pitches in Hertz over a fundamental\n\n        Parameters:\n            fundamental: The scale's 0 degree (fundamental) pitch in Hertz.\n\n        Returns:\n            The scale's pitches as Hertz\n\n        Examples:\n            &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).hertz(60.)\n            [60.0, 64.0, 72.0, 80.0, 90.0, 96.0, 108.0, 120.0]\n        \"\"\"\n        return [fundamental * tone for tone in self.tones]\n\n    @property\n    def genera(self) -&gt; Tuple[str, ...]:\n\"\"\"JustTetrachordalScale genera for each constituent tetrachord.\n\n        Examples:\n            &gt;&gt;&gt; intervals = []\n            &gt;&gt;&gt; intervals.append(JustInterval(32, 31))\n            &gt;&gt;&gt; intervals.append(JustInterval(31, 30))\n            &gt;&gt;&gt; intervals.append(JustInterval(5, 4))\n            &gt;&gt;&gt; scale = JustTetrachordalScale(JustTetrachord(intervals))\n            &gt;&gt;&gt; scale.upper = JustTetrachord(genus='diatonic')\n            &gt;&gt;&gt; scale.genera\n            ('enharmonic', 'diatonic')\n        \"\"\"\n        return (self.lower.genus, self.upper.genus)\n\n    @property\n    def is_equal(self) -&gt; bool:\n\"\"\"Evaluates whether the JustTetrachordalScale is equal or mixed.\"\"\"\n        return self.lower == self.upper\n\n    @property\n    def prime_limit(self) -&gt; int:\n\"\"\"JustTetrachordalScale prime limit.\"\"\"\n        return max(self.lower.prime_limit, self.upper.prime_limit)\n\n    @property\n    def permutations(self) -&gt; List[JustTetrachordalScale]:\n\"\"\"All (thirty-six) possible permutations of the JustTetrachordalScale.\"\"\"\n        return [\n            JustTetrachordalScale(pair[0], pair[1])\n            for pair in product(self.lower.permutations, self.upper.permutations)\n        ]\n\n    def __repr__(self):\n\"\"\"repr(self)\"\"\"\n        pitches = \", \".join(\n            [\n                \"/\".join([str(interval.numerator), str(interval.denominator)])\n                for interval in self.intervals\n            ]\n        )\n        return \"{}([{}])\".format(self.__class__.__name__, pitches)\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.lower","title":"<code>lower: JustTetrachord</code>  <code>writable</code> <code>property</code>","text":"<p>Lower JustTetrachord.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.upper","title":"<code>upper: JustTetrachord</code>  <code>writable</code> <code>property</code>","text":"<p>Upper JustTetrachord.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.intervals","title":"<code>intervals: List[JustInterval]</code>  <code>property</code>","text":"<p>JustTetrachordalScale intervals.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).intervals\n[JustInterval(16, 15), JustInterval(9, 8), JustInterval(10, 9),\nJustInterval(9, 8), JustInterval(16, 15), JustInterval(9, 8),\nJustInterval(10, 9)]\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.complement","title":"<code>complement: JustScale</code>  <code>property</code>","text":"<p>JustTetrachordalScale complement</p> Note <p>Returns a JustScale! The result will not be Tetrachordal.</p> <p>Returns:</p> Type Description <code>JustScale</code> <p>The JustScale that is the complement</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='chromatic')).complement\nJustScale([1/1, 6/5, 9/7, 4/3, 3/2, 9/5, 27/14, 2/1])\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.tones","title":"<code>tones: List[JustInterval]</code>  <code>property</code>","text":"<p>JustTetrachordalScale tones.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).tones\n[JustInterval(1, 1), JustInterval(16, 15), JustInterval(6, 5),\nJustInterval(4, 3), JustInterval(3, 2), JustInterval(8, 5),\nJustInterval(9, 5), JustInterval(2, 1)]\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.genera","title":"<code>genera: Tuple[str, ...]</code>  <code>property</code>","text":"<p>JustTetrachordalScale genera for each constituent tetrachord.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; intervals = []\n&gt;&gt;&gt; intervals.append(JustInterval(32, 31))\n&gt;&gt;&gt; intervals.append(JustInterval(31, 30))\n&gt;&gt;&gt; intervals.append(JustInterval(5, 4))\n&gt;&gt;&gt; scale = JustTetrachordalScale(JustTetrachord(intervals))\n&gt;&gt;&gt; scale.upper = JustTetrachord(genus='diatonic')\n&gt;&gt;&gt; scale.genera\n('enharmonic', 'diatonic')\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.is_equal","title":"<code>is_equal: bool</code>  <code>property</code>","text":"<p>Evaluates whether the JustTetrachordalScale is equal or mixed.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.prime_limit","title":"<code>prime_limit: int</code>  <code>property</code>","text":"<p>JustTetrachordalScale prime limit.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.permutations","title":"<code>permutations: List[JustTetrachordalScale]</code>  <code>property</code>","text":"<p>All (thirty-six) possible permutations of the JustTetrachordalScale.</p>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.__init__","title":"<code>__init__(lower, upper=None)</code>","text":"<p>Initializes a JustTetrachordalScale.</p> <p>Parameters:</p> Name Type Description Default <code>lower</code> <code>JustTetrachord</code> <p>The lower tetrachord</p> required <code>upper</code> <code>Optional[JustTetrachord]</code> <p>The upper tetrachord. If None is passed, the lower tetrachord is also used for the upper, creating an 'equal' tetrachordal scale.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='enharmonic'))\nJustTetrachordalScale([46/45, 24/23, 5/4, 9/8, 46/45, 24/23, 5/4])\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def __init__(\n    self,\n    lower: JustTetrachord,\n    upper: Optional[JustTetrachord] = None,\n):\n\"\"\"Initializes a JustTetrachordalScale.\n\n    Parameters:\n        lower: The lower tetrachord\n        upper: The upper tetrachord. If None is passed, the lower tetrachord\n            is also used for the upper, creating an 'equal' tetrachordal scale.\n\n    Examples:\n        &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='enharmonic'))\n        JustTetrachordalScale([46/45, 24/23, 5/4, 9/8, 46/45, 24/23, 5/4])\n    \"\"\"\n\n    self._lower = lower\n    if upper is None:\n        self._upper = lower\n    else:\n        self._upper = upper\n</code></pre>"},{"location":"api/scales/#jintonic.scales.JustTetrachordalScale.hertz","title":"<code>hertz(fundamental)</code>","text":"<p>Translates scale intervals to pitches in Hertz over a fundamental</p> <p>Parameters:</p> Name Type Description Default <code>fundamental</code> <code>float</code> <p>The scale's 0 degree (fundamental) pitch in Hertz.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>The scale's pitches as Hertz</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).hertz(60.)\n[60.0, 64.0, 72.0, 80.0, 90.0, 96.0, 108.0, 120.0]\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/jintonic/scales.py</code> <pre><code>def hertz(self, fundamental: float) -&gt; List[float]:\n\"\"\"Translates scale intervals to pitches in Hertz over a fundamental\n\n    Parameters:\n        fundamental: The scale's 0 degree (fundamental) pitch in Hertz.\n\n    Returns:\n        The scale's pitches as Hertz\n\n    Examples:\n        &gt;&gt;&gt; JustTetrachordalScale(JustTetrachord(genus='diatonic')).hertz(60.)\n        [60.0, 64.0, 72.0, 80.0, 90.0, 96.0, 108.0, 120.0]\n    \"\"\"\n    return [fundamental * tone for tone in self.tones]\n</code></pre>"}]}